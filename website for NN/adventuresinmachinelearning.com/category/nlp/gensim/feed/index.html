<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>gensim &#8211; Adventures in Machine Learning</title>
	<atom:link href="http://adventuresinmachinelearning.com/category/nlp/gensim/feed/" rel="self" type="application/rss+xml" />
	<link>http://adventuresinmachinelearning.com</link>
	<description>Learn and explore machine learning</description>
	<lastBuildDate>Sun, 09 Sep 2018 07:53:16 +0000</lastBuildDate>
	<language>en-AU</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>
	<item>
		<title>Python gensim Word2Vec tutorial with TensorFlow and Keras</title>
		<link>http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/</link>
		<comments>http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/#comments</comments>
		<pubDate>Fri, 01 Sep 2017 22:24:41 +0000</pubDate>
		<dc:creator><![CDATA[Andy]]></dc:creator>
				<category><![CDATA[gensim]]></category>
		<category><![CDATA[Keras]]></category>
		<category><![CDATA[NLP]]></category>
		<category><![CDATA[TensorFlow]]></category>
		<category><![CDATA[Word2Vec]]></category>

		<guid isPermaLink="false">http://adventuresinmachinelearning.com/?p=517</guid>
		<description><![CDATA[<p>I&#8217;ve been dedicating quite a bit of time recently to Word2Vec tutorials because of the importance of the Word2Vec concept for natural language processing (NLP) <a class="mh-excerpt-more" href="http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/" title="Python gensim Word2Vec tutorial with TensorFlow and Keras">[...]</a></p>
<p>The post <a rel="nofollow" href="http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/">Python gensim Word2Vec tutorial with TensorFlow and Keras</a> appeared first on <a rel="nofollow" href="http://adventuresinmachinelearning.com">Adventures in Machine Learning</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>I&#8217;ve been dedicating quite a bit of time recently to Word2Vec tutorials because of the importance of the Word2Vec concept for natural language processing (NLP) and also because I&#8217;ll soon be presenting some tutorials on recurrent neural networks and LSTMs for sequence prediction/NLP (UPDATE: I&#8217;ve completed a comprehensive tutorial on these topics &#8211; <a href="http://adventuresinmachinelearning.com/recurrent-neural-networks-lstm-tutorial-tensorflow/" target="_blank" rel="noopener">Recurrent neural networks and LSTM tutorial in Python and TensorFlow</a>).  There are also some very interesting ideas floating around such as <a href="https://deeplearning4j.org/thoughtvectors" target="_blank" rel="noopener">thought vectors</a> which require an understanding of the Word2Vec concept.  My two Word2Vec tutorials are <a href="http://adventuresinmachinelearning.com/word2vec-tutorial-tensorflow/" target="_blank" rel="noopener">Word2Vec word embedding tutorial in Python and TensorFlow</a> and <a href="http://adventuresinmachinelearning.com/word2vec-keras-tutorial/" target="_blank" rel="noopener">A Word2Vec Keras tutorial</a> showing the concepts of Word2Vec and implementing in TensorFlow and Keras, respectively.  In this tutorial, I am going to show you how you can use the original Google Word2Vec C code to generate word vectors, using the Python gensim library which wraps this cod,e and apply the results to TensorFlow and Keras.</p>
<p>The gensim Word2Vec implementation is very fast due to its C implementation &#8211; but to use it properly you will first need to install the <a href="http://cython.org/" target="_blank" rel="noopener">Cython library</a>. In this tutorial, I&#8217;ll show how to load the resulting embedding layer generated by gensim into TensorFlow and Keras embedding implementations.  Because of gensim&#8217;s blazing fast C wrapped code, this is a good alternative to running native Word2Vec embeddings in TensorFlow and Keras.</p>
<hr />
<p><strong>Recommended online course: </strong>If you are more of a video course learner, check out this inexpensive Udemy course: <a href="https://click.linksynergy.com/link?id=Jbc0N5ZkDzk&amp;offerid=323058.918390&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fnatural-language-processing-with-deep-learning-in-python%2F" target="new">Natural Language Processing with Deep Learning in Python</a><img src="https://ad.linksynergy.com/fs-bin/show?id=Jbc0N5ZkDzk&amp;bids=323058.918390&amp;type=2&amp;subid=0" width="1" height="1" border="0" /></p>
<hr />
<h1>Word2Vec and gensim</h1>
<p>I&#8217;ve devoted plenty of words to explaining Word2Vec in my previous tutorials (<a href="http://adventuresinmachinelearning.com/word2vec-tutorial-tensorflow/" target="_blank" rel="noopener">here</a> and <a href="http://adventuresinmachinelearning.com/word2vec-keras-tutorial/" target="_blank" rel="noopener">here</a>) so I&#8217;ll only briefly introduce the Word2Vec concepts here.  For further details, check out those tutorials. Here&#8217;s the (relatively) quick version &#8211; for each text data set that we create, we have to create a <em>vocabulary</em>. The <em>vocabulary</em> is the list of unique words within the text.  Often it is &gt;10,000 words for serious data sets.  Machine learning models generally can&#8217;t take raw word inputs, so we first need to convert our data set into some number format &#8211; generally a list of unique integers.</p>
<p>Neural network based models like vector inputs. We, therefore, need to convert the integers into vectors.  A naive way of converting integers into vectors is to convert them into one-hot vectors &#8211; these are vectors where all of the values are set to zero, except for one i.e. [0, 0, 0, &#8230;, 1, &#8230;, 0, 0].  The &#8220;one-hot&#8221; value is located at the array index which matches the unique integer representation of the word. Therefore, our input one-hot vector must be at least the size of the vocabulary in length &#8211; i.e. &gt;10,000 words.</p>
<p>There are two main problems with this type of representation of words &#8211; the first is that it is inefficient. Each word is represented by a 10,000 word plus vector, which for neural networks means a heck of a lot of associated weights between the input layer and the first hidden layer (generally millions).  The second is that it loses all contextual meaning of the words.  We need a way of representing words that is both efficient and yet retains some of the original meaning of the word and its relation to other words. Enter word embedding and Word2Vec.</p>
<h2>Word embedding and Word2Vec</h2>
<p>Word embedding involves creating better vector representations of words &#8211; both in terms of efficiency and maintaining meaning. For instance, a word embedding layer may involve creating a 10,000 x 300 sized matrix, whereby we look up a 300 length vector representation for each of the 10,000 words in our vocabulary.  This new, 300 length vector is obviously a lot more efficient than a 10,000 length one-hot representation.  But we also need to create this 300 length vector in such a way as to preserve some semblance of the meaning of the word.</p>
<p>Word2Vec does this by taking the <em>context </em>of words surrounding the <em>target </em>word.  So, if we have a context window of 2, the context of the <em>target</em> word &#8220;sat&#8221; in the sentence &#8220;the cat sat on the mat&#8221; is the list of words [&#8220;the&#8221;, &#8220;cat&#8221;, &#8220;on&#8221;, &#8220;the&#8221;]. In Word2Vec, the meaning of a word is roughly translatable to context &#8211; and it basically works. Target words which share similar common context words often have similar meanings. The way Word2Vec trains the embedding vectors is via a neural network of sorts &#8211; the neural network, given a one-hot representation of a <em>target</em> word, tries to predict the most likely context words.  For an introduction to neural networks, see <a href="http://adventuresinmachinelearning.com/neural-networks-tutorial/" target="_blank" rel="noopener">this tutorial</a>.</p>
<p>Here&#8217;s a naive way of performing the neural network training using an output softmax layer:</p>
<figure id="attachment_395" style="width: 676px" class="wp-caption alignnone"><img class="size-full wp-image-395" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/07/Word2Vec-softmax.jpg" alt="gensim word embedding softmax trainer" width="676" height="425" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/07/Word2Vec-softmax.jpg 676w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/07/Word2Vec-softmax-300x189.jpg 300w" sizes="(max-width: 676px) 100vw, 676px" /><figcaption class="wp-caption-text">A word embedding softmax trainer</figcaption></figure>
<p>In this network, the 300 node hidden layer weights are training by trying to predict (via a softmax output layer) genuine, high probability context words.  Once the training is complete, the output softmax layer is discarded and what is of real value is the 10,000 x 300 weight matrix connecting the input to the hidden layer. This is our embedding matrix, and we can look up any member of our 10,000-word vocabulary and get it&#8217;s 300 length vector representation.</p>
<p>It turns out that this softmax way of training the embedding layer is very inefficient, due to the millions of weights that need to be involved in updating and calculating the softmax values. Therefore, a concept called <em>negative sampling </em>is used in the real Word2Vec, which involves training the layer with real context words and a few <em>negative samples</em> which are chosen randomly from outside the context.  For more details on this, see my <a href="http://adventuresinmachinelearning.com/word2vec-keras-tutorial/" target="_blank" rel="noopener">Word2Vec Keras tutorial</a>.</p>
<p>Now we understand what Word2Vec training of embedding layers involves, let&#8217;s talk about the gensim Word2Vec module.</p>
<h2>A gensim Word2Vec tutorial</h2>
<figure id="attachment_532" style="width: 1139px" class="wp-caption alignnone"><img class="size-full wp-image-532" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Closest-words-output.jpg" alt="gensim Word2Vec - nearest words" width="1139" height="327" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Closest-words-output.jpg 1139w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Closest-words-output-300x86.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Closest-words-output-768x220.jpg 768w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/09/Closest-words-output-1024x294.jpg 1024w" sizes="(max-width: 1139px) 100vw, 1139px" /><figcaption class="wp-caption-text">Nearest words by cosine similarity</figcaption></figure>
<p>This section will give a brief introduction to the gensim Word2Vec module.  The gensim library is an open-source Python library that specializes in vector space and topic modeling.  It can be made very fast with the use of the Cython Python model, which allows C code to be run inside the Python environment. This is good for our purposes, as the <a href="https://code.google.com/archive/p/word2vec/" target="_blank" rel="noopener">original Google Word2Vec implementation</a> is written in C, and gensim has a wrapper for this code, which will be explained below.</p>
<p>For this tutorial, we are going to use the <em>text8</em> corpus sourced from <a href="http://mattmahoney.net/dc/" target="_blank" rel="noopener">here</a> for our text data. All the code for this tutorial can be found on this site&#8217;s <a href="https://github.com/adventuresinML/adventures-in-ml-code" target="_blank" rel="noopener">Github repository</a>.</p>
<p>First off, we need to download the <em>text8.zip</em> file (if required) and extract it:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">url = &#039;http://mattmahoney.net/dc/&#039;
filename = maybe_download(&#039;text8.zip&#039;, url, 31344016)
root_path = &quot;C:\\Users\Andy\PycharmProjects\\adventures-in-ml-code\\&quot;
if not os.path.exists((root_path + filename).strip(&#039;.zip&#039;)):
    zipfile.ZipFile(root_path+filename).extractall()</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This is all fairly straightforward Python file handling, downloading and zip file manipulation, so I won&#8217;t go into it here.</p>
<p>The next step that is required is to create an iterator for gensim to extract its data from.  We can cheat a little bit here and use a supplied iterator that gensim provides for the <em>text8</em> corpus:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">sentences = word2vec.Text8Corpus((root_path + filename).strip(&#039;.zip&#039;))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The required input to the gensim Word2Vec module is an <a href="http://pymbook.readthedocs.io/en/latest/igd.html" target="_blank" rel="noopener">iterator object</a>, which sequentially supplies sentences from which gensim will train the embedding layer. The line above shows the supplied gensim iterator for the <em>text8</em> corpus, but below shows another generic form that could be used in its place for a different data set (not actually implemented in the code for this tutorial), where the data set also contains multiple files:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">class MySentences(object):
    def __init__(self, dirname):
        self.dirname = dirname
 
    def __iter__(self):
        for fname in os.listdir(self.dirname):
            for line in open(os.path.join(self.dirname, fname)):
                yield line.split()</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This capability of gensim is great, as it means you can setup iterators which cycle through the data without having to load the entire data set into memory.  This is vital, as some text data sets are huge  i.e. tens of GB.</p>
<p>After we&#8217;ve setup the iterator object, it is dead simple to train our word vectors:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">logging.basicConfig(format=&#039;%(asctime)s : %(levelname)s : %(message)s&#039;, level=logging.INFO)
model = word2vec.Word2Vec(sentences, iter=10, min_count=10, size=300, workers=4)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The first line just lets us see the INFO logging that gensim provides as it trains. The second line will execute the training on the provided <em>sentences</em> iterator.  The first optional argument <em>iter</em> specifies how many times the training code will run through the data set to train the neural network (kind of like the number of training epochs). The gensim training code will actually run through all the data <em>iter+1</em> time, as the first pass involves collecting all the unique words, creating dictionaries etc.  The next argument,<em> min_count,</em> specifies the minimum amount of times that the word has to appear in the corpus before it is included in the vocabulary &#8211; this allows us to easily eliminate rare words and reduce our vocabulary size.  The third argument is the size of the resultant word vector &#8211; in this case, we set it to 300. In other words, each word in our vocabulary, after training, will be represented by a 300 length word vector. Finally, if we are using Cython, we can specify how many parallel workers we would like to work on the data &#8211; this will speed up the training process. There are <a href="https://radimrehurek.com/gensim/models/word2vec.html" target="_blank" rel="noopener">lots of other arguments</a>, but these are the main ones to consider.</p>
<p>Let&#8217;s examine our results and see what else gensim can do.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># get the word vector of &quot;the&quot;
print(model.wv[&#039;the&#039;])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This returns a 300 length numpy vector &#8211; as you can see, each word vector can be retrieved from the model via a dictionary key i.e. a word within our vocabulary.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># get the most common words
print(model.wv.index2word[0], model.wv.index2word[1], model.wv.index2word[2])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The word vectors are also arranged within the <em>wv</em> object with indexes &#8211; the lowest index (i.e. 0) represents the most common word, the highest (i.e. the length of the vocabulary minus 1) the least common word.  The above code returns: &#8220;the of and&#8221;, which is unsurprising, as these are very common words.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># get the least common words
vocab_size = len(model.wv.vocab)
print(model.wv.index2word[vocab_size - 1], model.wv.index2word[vocab_size - 2], model.wv.index2word[vocab_size - 3])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The discovered vocabulary is found in <em>model.wv.vocab</em> &#8211; by taking the length of this dictionary, we can determine the vocabulary size (in this case, it is 47,134 elements long). The code above returns: &#8220;zanetti markschies absentia&#8221; &#8211; rare words indeed.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># find the index of the 2nd most common word (&quot;of&quot;)
print(&#039;Index of &quot;of&quot; is: {}&#039;.format(model.wv.vocab[&#039;of&#039;].index))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>We can also go the other way i.e. retrieve the index of a word we supply.  In this case, we are getting the index of the second most common word &#8220;of&#8221;. As expected the above code returns &#8220;Index of &#8220;of&#8221; is: 1&#8243;.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># some similarity fun
print(model.wv.similarity(&#039;woman&#039;, &#039;man&#039;), model.wv.similarity(&#039;man&#039;, &#039;elephant&#039;))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>We can also easily extract similarity measures between word vectors (gensim uses <a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noopener">cosine similarity</a>). The above code returns &#8220;0.6599 0.2955&#8221;, which again makes sense given the context such words are generally used in.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># what doesn&#039;t fit?
print(model.wv.doesnt_match(&quot;green blue red zebra&quot;.split()))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This fun function determines which word doesn&#8217;t match the context of the others &#8211; in this case, &#8220;zebra&#8221; is returned.</p>
<p>We also want to able to convert our data set from a list of words to a list of integer indexes, based on the vocabulary developed by gensim.  To do so, we can use the following code:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># convert the input data into a list of integer indexes aligning with the wv indexes
# Read the data into a list of strings.
def read_data(filename):
    &quot;&quot;&quot;Extract the first file enclosed in a zip file as a list of words.&quot;&quot;&quot;
    with zipfile.ZipFile(filename) as f:
        data = f.read(f.namelist()[0]).split()
    return data

def convert_data_to_index(string_data, wv):
    index_data = []
    for word in string_data:
        if word in wv:
            index_data.append(wv.vocab[word].index)
    return index_data

str_data = read_data(root_path + filename)
index_data = convert_data_to_index(str_data, model.wv)
print(str_data[:4], index_data[:4])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The first function, <em>read_data</em> simply extracts the zip file data and returns a list of strings in the same order as our original text data set.  The second function loops through each word in the data set, determines if it is in the vocabulary*, and if so, adds the matching integer index to a list.  The code above returns: &#8220;[&#8216;anarchism&#8217;, &#8216;originated&#8217;, &#8216;as&#8217;, &#8216;a&#8217;] [5237, 3080, 11, 5]&#8221;.</p>
<p>* Remember that some words in the data set will be missing from the vocabulary if they are very rare in the corpus.</p>
<p>We can also save and reload our trained word vectors/embeddings by the following simple code:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># save and reload the model
model.save(root_path + &quot;mymodel&quot;)
model = gensim.models.Word2Vec.load(root_path + &quot;mymodel&quot;)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Finally, I&#8217;ll show you how we can extract the embedding weights from the gensim Word2Vec embedding layer and store it in a numpy array, ready for use in TensorFlow and Keras.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># convert the wv word vectors into a numpy matrix that is suitable for insertion
# into our TensorFlow and Keras models
embedding_matrix = np.zeros((len(model.wv.vocab), vector_dim))
for i in range(len(model.wv.vocab)):
    embedding_vector = model.wv[model.wv.index2word[i]]
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector</code></pre> <div class="code-embed-infos"> </div> </div>
<p>In this case, we first create an appropriately sized numpy zeros array.  Then we loop through each word in the vocabulary, grabbing the word vector associated with that word by using the <em>wv</em> dictionary.  We then add the word vector into our numpy array.</p>
<p>So there we have it &#8211; gensim Word2Vec is a great little library that can execute the word embedding process very quickly, and also has a host of other useful functionality.</p>
<p>Now I will show how you can use pre-trained gensim embedding layers in our TensorFlow and Keras models.</p>
<h1>Using gensim Word2Vec embeddings in TensorFlow</h1>
<p>For this application, we&#8217;ll setup a dummy TensorFlow network with an embedding layer and measure the similarity between some words.  If you&#8217;re not up to speed with TensorFlow, I suggest you check out my <a href="http://adventuresinmachinelearning.com/python-tensorflow-tutorial/" target="_blank" rel="noopener">TensorFlow tutorial</a> or this online course <a href="https://click.linksynergy.com/link?id=Jbc0N5ZkDzk&amp;offerid=323058.772462&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdata-science-deep-learning-in-theano-tensorflow%2F" target="new">Data Science: Practical Deep Learning in Theano + TensorFlow</a><img src="https://ad.linksynergy.com/fs-bin/show?id=Jbc0N5ZkDzk&amp;bids=323058.772462&amp;type=2&amp;subid=0" width="1" height="1" border="0" />.  Also, it&#8217;s probably a good idea to check out my <a href="http://adventuresinmachinelearning.com/word2vec-tutorial-tensorflow/" target="_blank" rel="noopener">Word2Vec TensorFlow tutorial</a> to understand how the embedding layer works.</p>
<p>The first step is to select some random words from the top 100 most common words in our text data set.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">valid_size = 16  # Random set of words to evaluate similarity on.
valid_window = 100  # Only pick dev samples in the head of the distribution.
valid_examples = np.random.choice(valid_window, valid_size, replace=False)
valid_dataset = tf.constant(valid_examples, dtype=tf.int32)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The last line saves the array of 16 random words into a TensorFlow constant <em>valid_dataset.</em></p>
<p>For the next step, we take the embedding matrix from our gensim Word2Vec simulation and &#8220;implant it&#8221; into a TensorFlow variable which we use as our embedding layer.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># embedding layer weights are frozen to avoid updating embeddings while training
saved_embeddings = tf.constant(embedding_matrix)
embedding = tf.Variable(initial_value=saved_embeddings, trainable=False)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Note that in the second line above for the TensorFlow variable declaration, I&#8217;ve set the <em>trainable</em> argument to <em>False. </em>If we were using this layer in, say, training a recurrent neural network, if we didn&#8217;t set this argument to <em>False</em> our embedding layer would be trained in TensorFlow with negative performance impacts. It&#8217;s probably not an overall bad strategy, i.e. starting with a gensim embedding matrix and then training further using something like a recurrent NN, but if you want your embedding layer fixed for performance reasons, you need to set <em>trainable</em> to <em>False</em>.</p>
<p>The next chunk of code calculates the similarity between each of the word vectors using the <a href="https://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noopener">cosine similarity</a> measure. It is explained more fully in my <a href="http://adventuresinmachinelearning.com/word2vec-tutorial-tensorflow/" target="_blank" rel="noopener">Word2Vec TensorFlow tutorial</a>, but basically it calculates the norm of all the embedding vectors, then performs a dot product between the validation words and all other word vectors.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># create the cosine similarity operations
norm = tf.sqrt(tf.reduce_sum(tf.square(embedding), 1, keep_dims=True))
normalized_embeddings = embedding / norm
valid_embeddings = tf.nn.embedding_lookup(
      normalized_embeddings, valid_dataset)
similarity = tf.matmul(valid_embeddings, normalized_embeddings, transpose_b=True)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Now we can run our TensorFlow session and sort the eight words which are closest to our validation example words.  Again, this code is explained in more detail in the previously mentioned tutorial.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code"># Add variable initializer.
init = tf.global_variables_initializer()

with tf.Session() as sess:
    sess.run(init)
    # call our similarity operation
    sim = similarity.eval()
    # run through each valid example, finding closest words
    for i in range(valid_size):
        valid_word = wv.index2word[i]
        top_k = 8  # number of nearest neighbors
        nearest = (-sim[i, :]).argsort()[1:top_k + 1]
        log_str = &#039;Nearest to %s:&#039; % valid_word
            for k in range(top_k):
            close_word = wv.index2word[nearest[k]]
            log_str = &#039;%s %s,&#039; % (log_str, close_word)
        print(log_str)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This code will produce lines like:</p>
<blockquote><p>Nearest to two: three, five, zero, four, six, one, seven, eight</p></blockquote>
<p>As you can see, our Word2Vec embeddings produced by gensim have the expected results &#8211; in this example, we have number words being grouped together in similarity which makes sense.</p>
<p>Next up, let&#8217;s see how we can use the gensim Word2Vec embeddings in Keras.</p>
<h1>Using gensim Word2Vec embeddings in Keras</h1>
<p>We can perform similar steps with a Keras model. In this case, following the example code previously shown in <a href="http://adventuresinmachinelearning.com/word2vec-keras-tutorial/" target="_blank" rel="noopener">the Keras Word2Vec tutorial</a>, our model takes two single word samples as input and finds the similarity between them.  The top 8 closest words loop is therefore slightly different than the previous example:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">valid_size = 16  # Random set of words to evaluate similarity on.
valid_window = 100  # Only pick dev samples in the head of the distribution.
valid_examples = np.random.choice(valid_window, valid_size, replace=False)
# input words - in this case we do sample by sample evaluations of the similarity
valid_word = Input((1,), dtype=&#039;int32&#039;)
other_word = Input((1,), dtype=&#039;int32&#039;)
# setup the embedding layer
embeddings = Embedding(input_dim=embedding_matrix.shape[0], output_dim=embedding_matrix.shape[1],
                      weights=[embedding_matrix])
embedded_a = embeddings(valid_word)
embedded_b = embeddings(other_word)
similarity = merge([embedded_a, embedded_b], mode=&#039;cos&#039;, dot_axes=2)
# create the Keras model
k_model = Model(input=[valid_word, other_word], output=similarity)

def get_sim(valid_word_idx, vocab_size):
    sim = np.zeros((vocab_size,))
    in_arr1 = np.zeros((1,))
        in_arr2 = np.zeros((1,))
    in_arr1[0,] = valid_word_idx
    for i in range(vocab_size):
        in_arr2[0,] = i
        out = k_model.predict_on_batch([in_arr1, in_arr2])
        sim[i] = out
    return sim

# now run the model and get the closest words to the valid examples
for i in range(valid_size):
    valid_word = wv.index2word[valid_examples[i]]
    top_k = 8  # number of nearest neighbors
    sim = get_sim(valid_examples[i], len(wv.vocab))
    nearest = (-sim).argsort()[1:top_k + 1]
    log_str = &#039;Nearest to %s:&#039; % valid_word
    for k in range(top_k):
        close_word = wv.index2word[nearest[k]]
        log_str = &#039;%s %s,&#039; % (log_str, close_word)
    print(log_str)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>As you can see when I setup the <em>embeddings</em> layer (using Keras&#8217; dedicated <em>Embedding()</em> layer), all we need to do is specify the input and output dimensions (vocabulary size and embedding vector length, respectively) and then assign the gensim <em>embedding_matrix </em>to the <em>weights</em> argument. All the remaining logic is a copy from the <a href="http://adventuresinmachinelearning.com/word2vec-keras-tutorial/" target="_blank" rel="noopener">Keras Word2Vec tutorial</a>, so check that post out for more details.</p>
<p>The code produces lines like:</p>
<blockquote><p>Nearest to when: unless, if, where, whenever, then, before, once, finally</p></blockquote>
<p>Here we can see that <a href="https://en.wikipedia.org/wiki/Conjunction_(grammar)" target="_blank" rel="noopener">subordinating conjunction</a> word types have been grouped together &#8211; which is a good, expected result.</p>
<p>So that wraps up the tutorial &#8211; in this post, I&#8217;ve shown you how to use gensim to create Word2Vec word embeddings in a quick and efficient fashion.  I then gave an overview of how to &#8220;upload&#8221; these learned embeddings into TensorFlow and Keras.  I hope it has been helpful.</p>
<p>&nbsp;</p>
<hr />
<p><strong>Recommended online course: </strong>If you are more of a video course learner, check out this inexpensive Udemy course: <a href="https://click.linksynergy.com/link?id=Jbc0N5ZkDzk&amp;offerid=323058.918390&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fnatural-language-processing-with-deep-learning-in-python%2F" target="new">Natural Language Processing with Deep Learning in Python</a><img src="https://ad.linksynergy.com/fs-bin/show?id=Jbc0N5ZkDzk&amp;bids=323058.918390&amp;type=2&amp;subid=0" width="1" height="1" border="0" /></p>
<hr />
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/">Python gensim Word2Vec tutorial with TensorFlow and Keras</a> appeared first on <a rel="nofollow" href="http://adventuresinmachinelearning.com">Adventures in Machine Learning</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://adventuresinmachinelearning.com/gensim-word2vec-tutorial/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
		</item>
	</channel>
</rss>
