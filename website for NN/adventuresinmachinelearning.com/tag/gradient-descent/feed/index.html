<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Gradient descent &#8211; Adventures in Machine Learning</title>
	<atom:link href="http://adventuresinmachinelearning.com/tag/gradient-descent/feed/" rel="self" type="application/rss+xml" />
	<link>http://adventuresinmachinelearning.com</link>
	<description>Learn and explore machine learning</description>
	<lastBuildDate>Sun, 09 Sep 2018 07:53:16 +0000</lastBuildDate>
	<language>en-AU</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>
	<item>
		<title>Neural Networks Tutorial &#8211; A Pathway to Deep Learning</title>
		<link>http://adventuresinmachinelearning.com/neural-networks-tutorial/</link>
		<comments>http://adventuresinmachinelearning.com/neural-networks-tutorial/#comments</comments>
		<pubDate>Sat, 18 Mar 2017 03:05:37 +0000</pubDate>
		<dc:creator><![CDATA[Andy]]></dc:creator>
				<category><![CDATA[Deep learning]]></category>
		<category><![CDATA[Neural networks]]></category>
		<category><![CDATA[Gradient descent]]></category>
		<category><![CDATA[Python]]></category>
		<category><![CDATA[Tutorials]]></category>

		<guid isPermaLink="false">http://adventuresinmachinelearning.com/?p=20</guid>
		<description><![CDATA[<p>Chances are, if you are searching for a tutorial on artificial neural networks (ANN) you already have some idea of what they are, and what <a class="mh-excerpt-more" href="http://adventuresinmachinelearning.com/neural-networks-tutorial/" title="Neural Networks Tutorial &#8211; A Pathway to Deep Learning">[...]</a></p>
<p>The post <a rel="nofollow" href="http://adventuresinmachinelearning.com/neural-networks-tutorial/">Neural Networks Tutorial &#8211; A Pathway to Deep Learning</a> appeared first on <a rel="nofollow" href="http://adventuresinmachinelearning.com">Adventures in Machine Learning</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Chances are, if you are searching for a tutorial on artificial neural networks (ANN) you already have some idea of what they are, and what they are capable of doing.  But did you know that neural networks are the foundation of the new and exciting field of deep learning?  Deep learning is the field of machine learning that is making many state-of-the-art advancements, from beating players at <a href="http://www.sciencemag.org/news/2016/01/huge-leap-forward-computer-mimics-human-brain-beats-professional-game-go" target="_blank" rel="noopener noreferrer">Go</a> and <a href="http://www.sciencemag.org/news/2017/03/artificial-intelligence-goes-deep-beat-humans-poker" target="_blank" rel="noopener noreferrer">Poker</a> (<a href="http://adventuresinmachinelearning.com/reinforcement-learning-tutorial-python-keras/" target="_blank" rel="noopener">reinforcement learning</a>), to speeding up <a href="http://www.nanalyze.com/2016/01/4-companies-using-deep-learning-for-drug-discovery/" target="_blank" rel="noopener noreferrer">drug discovery</a> and <a href="http://spectrum.ieee.org/cars-that-think/transportation/self-driving/driveai-brings-deep-learning-to-selfdriving-cars" target="_blank" rel="noopener noreferrer">assisting self-driving cars</a>.  If these types of cutting edge applications excite you like they excite me, then you will be interesting in learning as much as you can about deep learning.  However, that requires you to know quite a bit about how neural networks work.  This tutorial article is designed to help you get up to speed in neural networks as quickly as possible.</p>
<p>In this tutorial I&#8217;ll be presenting some concepts, code and maths that will enable you to build <em>and understand</em> a simple neural network.  Some tutorials focus only on the code and skip the maths &#8211; but this impedes understanding. I&#8217;ll take things as slowly as possible, but it might help to brush up on your <a href="https://www.khanacademy.org/math/precalculus/precalc-matrices" target="_blank" rel="noopener noreferrer">matrices</a> and <a href="https://www.khanacademy.org/math/differential-calculus" target="_blank" rel="noopener noreferrer">differentiation</a> if you need to. The code will be in Python, so it will be beneficial if you have a basic understanding of how Python works.  You&#8217;ll pretty much get away with knowing about Python functions, loops and the basics of the <a href="http://www.numpy.org/">numpy</a> library.  By the end of this neural networks tutorial you&#8217;ll be able to build an ANN in Python that will correctly classify handwritten digits in images with a fair degree of accuracy.</p>
<p>Once you&#8217;re done with this tutorial, you can dive a little deeper with the following posts:</p>
<p><a href="http://adventuresinmachinelearning.com/python-tensorflow-tutorial/">Python TensorFlow Tutorial – Build a Neural Network</a><br />
<a href="http://adventuresinmachinelearning.com/improve-neural-networks-part-1/">Improve your neural networks – Part 1 [TIPS AND TRICKS]</a><br />
<a href="http://adventuresinmachinelearning.com/stochastic-gradient-descent/">Stochastic Gradient Descent – Mini-batch and more</a></p>
<p>All of the relevant code in this tutorial can be found <a href="https://github.com/adventuresinML/adventures-in-ml-code" target="_blank" rel="noopener noreferrer">here</a>.</p>
<hr />
<p><strong>Recommended online course: </strong>If you like video courses, I&#8217;d recommend the following inexpensive Udemy course on neural networks: <a href="https://click.linksynergy.com/link?id=Jbc0N5ZkDzk&amp;offerid=323058.1151632&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdeeplearning%2F" target="new">Deep Learning A-Z: Hands-On Artificial Neural Networks</a><img src="https://ad.linksynergy.com/fs-bin/show?id=Jbc0N5ZkDzk&amp;bids=323058.1151632&amp;type=2&amp;subid=0" width="1" height="1" border="0" /></p>
<hr />
<p>Here&#8217;s an outline of the tutorial, with links, so you can easily navigate to the parts you want:</p>
<p><a href="#what-are-anns">1 What are artificial neural networks?</a><br />
<a href="#structure-ann">2 The structure of an ANN</a><br />
<a href="#the-artificial-neuron">2.1 The artificial neuron</a><br />
<a href="#nodes">2.2 Nodes</a><br />
<a href="#the-bias">2.3 The bias</a><br />
<a href="#putting-together-the-structure">2.4 Putting together the structure</a><br />
<a href="#the-notation">2.5 The notation</a><br />
<strong><a href="#the-feed-forward-pass">3 The feed-forward pass</a></strong><br />
<a href="#the-feed-forward-pass">3.1 A feed-forward example</a><br />
<a href="#first-attempt-feed-forward">3.2 Our first attempt at a feed-forward function</a><br />
<a href="#more-efficient-implementation">3.3 A more efficient implementation</a><br />
<a href="#vectorisation">3.4 Vectorisation in neural networks</a><br />
<a href="#matrix-mult">3.5 Matrix multiplication</a><br />
<strong><a href="#gradient-desc-opt">4 Gradient descent and optimisation</a></strong><br />
<a href="#simple-example">4.1 A simple example in code</a><br />
<a href="#the-cost-function">4.2 The cost function</a><br />
<a href="#gradient-descent-in-nn">4.3 Gradient descent in neural networks</a><br />
<a href="#two-dimensional">4.4 A two dimensional gradient descent example</a><br />
<a href="#backprop-in-depth">4.5 Backpropagation in depth</a><br />
<a href="#prop-in-hidden-layers">4.6 Propagating into the hidden layers</a><br />
<a href="#vector-backprop">4.7 Vectorisation of backpropagation</a><br />
<a href="#imp-gradient-desc">4.8 Implementing the gradient descent step</a><br />
<a href="#final-gradient-desc-algo">4.9 The final gradient descent algorithm</a><br />
<strong><a href="#implementing-nn">5 Implementing the neural network in Python</a></strong><br />
<a href="#scaling-data">5.1 Scaling data</a><br />
<a href="#test-and-train">5.2 Creating test and training datasets</a><br />
<a href="#setting-up-output">5.3 Setting up the output layer</a><br />
<a href="#creating-nn">5.4 Creating the neural network</a><br />
<a href="#creating-nn">5.5 Assessing the accuracy of the trained model</a></p>
<h2 id="what-are-anns">1 What are artificial neural networks?</h2>
<p>Artificial neural networks (ANNs) are software implementations of the neuronal structure of our brains.  We don&#8217;t need to talk about the complex biology of our brain structures, but suffice to say, the brain contains <em>neurons</em> which are kind of like organic switches.  These can change their output state depending on the strength of their electrical or chemical input.  The neural network in a person&#8217;s brain is a hugely interconnected network of neurons, where the output of any given neuron may be the input to thousands of other neurons.  Learning occurs by repeatedly activating certain neural connections over others, and this reinforces those connections.  This makes them more likely to produce a desired outcome given a specified input.  This learning involves <em>feedback</em> &#8211; when the desired outcome occurs, the neural connections causing that outcome become strengthened.</p>
<p><em>Artificial</em> neural networks attempt to simplify and mimic this brain behaviour.  They can be trained in a <em>supervised</em> or <em>unsupervised</em> manner.  In a <em>supervised</em> ANN, the network is trained by providing matched input and output data samples, with the intention of getting the ANN to provide a desired output for a given input.  An example is an e-mail spam filter &#8211; the input training data could be the count of various words in the body of the e-mail, and the output training data would be a classification of whether the e-mail was truly spam or not.  If many examples of e-mails are passed through the neural network this allows the network to <em>learn </em>what input data makes it likely that an e-mail is spam or not.  This learning takes place be adjusting the <em>weights</em> of the ANN connections, but this will be discussed further in the next section.</p>
<p><em>Unsupervised</em> learning in an ANN is an attempt to get the ANN to &#8220;understand&#8221; the structure of the provided input data &#8220;on its own&#8221;.  This type of ANN will not be discussed in this post.</p>
<h2 id="structure-ann">2 The structure of an ANN</h2>
<h3 id="the-artificial-neuron">2.1 The artificial neuron</h3>
<p>The biological neuron is simulated in an ANN by an <em>activation function</em>. In classification tasks (e.g. identifying spam e-mails) this activation function has to have a &#8220;switch on&#8221; characteristic &#8211; in other words, once the input is greater than a certain value, the output should change state i.e. from 0 to 1, from -1 to 1 or from 0 to &gt;0. This simulates the &#8220;turning on&#8221; of a biological neuron. A common activation function that is used is the sigmoid function:</p>
<p>\begin{equation*}<br />
f(z) = \frac{1}{1+exp(-z)}<br />
\end{equation*}</p>
<p>Which looks like this:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">import matplotlib.pylab as plt
import numpy as np
x = np.arange(-8, 8, 0.1)
f = 1 / (1 + np.exp(-x))
plt.plot(x, f)
plt.xlabel(&#039;x&#039;)
plt.ylabel(&#039;f(x)&#039;)
plt.show()</code></pre> <div class="code-embed-infos"> </div> </div>
<p><img class="size-medium wp-image-40 aligncenter" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/sigmoid-300x210.png" alt="" width="300" height="210" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/sigmoid-300x210.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/sigmoid.png 538w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p>As can be seen in the figure above, the function is &#8220;activated&#8221; i.e. it moves from 0 to 1 when the input <em>x</em> is greater than a certain value. The sigmoid function isn&#8217;t a step function however, the edge is &#8220;soft&#8221;, and the output doesn&#8217;t change instantaneously. This means that there is a derivative of the function and this is important for the training algorithm which is discussed more in <a href="#gradient-desc-opt">Section 4</a>.</p>
<h3 id="nodes">2.2 Nodes</h3>
<p>As mentioned previously, biological neurons are connected hierarchical networks, with the outputs of some neurons being the inputs to others. We can represent these networks as connected layers of <em>nodes. </em>Each node takes multiple weighted inputs, applies the <em>activation function</em> to the summation of these inputs, and in doing so generates an output. I&#8217;ll break this down further, but to help things along, consider the diagram below:</p>
<figure id="attachment_49" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-49 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Node-diagram-300x125.jpg" alt="" width="300" height="125" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Node-diagram-300x125.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Node-diagram.jpg 481w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 2. Node with inputs</figcaption></figure>
<p>The circle in the image above represents the node. The node is the &#8220;seat&#8221; of the activation function, and takes the weighted inputs, sums them, then inputs them to the activation function. The output of the activation function is shown as <em>h</em> in the above diagram. Note: a <em>node</em> as I have shown above is also called a <em>perceptron</em> in some literature.</p>
<p>What about this &#8220;weight&#8221; idea that has been mentioned? The weights are real valued numbers (i.e. not binary 1s or 0s), which are multiplied by the inputs and then summed up in the node. So, in other words, the weighted input to the node above would be:</p>
<p>\begin{equation*}<br />
x_1w_1 + x_2w_2 + x_3w_3 + b<br />
\end{equation*}</p>
<p>Here the $w_i$ values are weights (ignore the $b$ for the moment).  What are these weights all about?  Well, they are the variables that are changed during the learning process, and, along with the input, determine the output of the node.  The $b$ is the weight of the +1 <em>bias</em> element &#8211; the inclusion of this bias enhances the flexibility of the node, which is best demonstrated in an example.</p>
<h3 id="the-bias">2.3 The bias</h3>
<p>Let&#8217;s take an extremely simple node, with only one input and one output:</p>
<p>&nbsp;</p>
<figure id="attachment_45" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-45 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node-300x51.jpg" alt="" width="300" height="51" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node-300x51.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node.jpg 481w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 2. Simple node</figcaption></figure>
<p>The input to the activation function of the node in this case is simply $x_1w_1$.  What does changing $w_1$ do in this simple network?</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">w1 = 0.5
w2 = 1.0
w3 = 2.0
l1 = &#039;w = 0.5&#039;
l2 = &#039;w = 1.0&#039;
l3 = &#039;w = 2.0&#039;
for w, l in [(w1, l1), (w2, l2), (w3, l3)]:
    f = 1 / (1 + np.exp(-x*w))
    plt.plot(x, f, label=l)
plt.xlabel(&#039;x&#039;)
plt.ylabel(&#039;h_w(x)&#039;)
plt.legend(loc=2)
plt.show()</code></pre> <div class="code-embed-infos"> </div> </div>
<figure id="attachment_54" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-54 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Weight-adjustment-example-300x210.png" alt="" width="300" height="210" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Weight-adjustment-example-300x210.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Weight-adjustment-example.png 538w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 4. Effect of adjusting weights</figcaption></figure>
<p>Here we can see that changing the weight changes the slope of the output of the sigmoid activation function, which is obviously useful if we want to model different strengths of relationships between the input and output variables.  However, what if we only want the output to change when x is greater than 1?  This is where the bias comes in &#8211; let&#8217;s consider the same network with a bias input:</p>
<figure id="attachment_56" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-56 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node-with-bias-300x126.png" alt="" width="300" height="126" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node-with-bias-300x126.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Simple-node-with-bias.png 481w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 5. Effect of bias</figcaption></figure>
<p>&nbsp;</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">w = 5.0
b1 = -8.0
b2 = 0.0
b3 = 8.0
l1 = &#039;b = -8.0&#039;
l2 = &#039;b = 0.0&#039;
l3 = &#039;b = 8.0&#039;
for b, l in [(b1, l1), (b2, l2), (b3, l3)]:
    f = 1 / (1 + np.exp(-(x*w+b)))
    plt.plot(x, f, label=l)
plt.xlabel(&#039;x&#039;)
plt.ylabel(&#039;h_wb(x)&#039;)
plt.legend(loc=2)
plt.show()</code></pre> <div class="code-embed-infos"> </div> </div>
<figure id="attachment_57" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-57 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Bias-adjustment-example-300x210.png" alt="" width="300" height="210" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Bias-adjustment-example-300x210.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Bias-adjustment-example.png 538w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 6. Effect of bias adjusments</figcaption></figure>
<p>In this case, the $w_1$ has been increased to simulate a more defined &#8220;turn on&#8221; function.  As you can see, by varying the bias &#8220;weight&#8221; $b$, you can change when the node activates.  Therefore, by adding a bias term, you can make the node simulate a generic <strong>if</strong> function, i.e. <em>if (x &gt; z) then 1 else 0</em>.  Without a bias term, you are unable to vary the <em>z</em> in that if statement, it will be always stuck around 0.  This is obviously very useful if you are trying to simulate conditional relationships.</p>
<h3 id="putting-together-the-structure">2.4 Putting together the structure</h3>
<p>Hopefully the previous explanations have given you a good overview of how a given node/neuron/perceptron in a neural network operates.  However, as you are probably aware, there are many such interconnected nodes in a fully fledged neural network.  These structures can come in a myriad of different forms, but the most common simple neural network structure consists of an <em>input layer</em>, a <em>hidden layer</em> and an <em>output layer</em>.  An example of such a structure can be seen below:</p>
<figure id="attachment_60" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-60 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network-300x158.png" alt="" width="300" height="158" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network-300x158.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network.png 591w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 10. Three layer neural network</figcaption></figure>
<p>The three layers of the network can be seen in the above figure &#8211; Layer 1 represents the <strong><em>input layer</em></strong>, where the external input data enters the network. Layer 2 is called the <strong><em>hidden layer</em></strong> as this layer is not part of the input or output. Note: neural networks can have many hidden layers, but in this case for simplicity I have just included one. Finally, Layer 3 is the <strong><em>output layer</em></strong>. You can observe the many connections between the layers, in particular between Layer 1 (L1) and Layer 2 (L2). As can be seen, each node in L1 has a connection to all the nodes in L2. Likewise for the nodes in L2 to the single output node L3. Each of these connections will have an associated weight.</p>
<h3 id="the-notation">2.5 The notation</h3>
<p>The maths below requires some fairly precise notation so that we know what we are talking about.  The notation I am using here is similar to that used in the Stanford deep learning tutorial.  In the upcoming equations, each of these weights are identified with the following notation: ${w_{ij}}^{(l)}$. $i$ refers to the node number of the connection in layer $l+1$ and $j$ refers to the node number of the connection in layer $l$. Take special note of this order. So, for the connection between node 1 in layer 1 and node 2 in layer 2, the weight notation would be ${w_{21}}^{(1)}$. This notation may seem a bit odd, as you would expect the *i* and *j* to refer the node numbers in layers $l$ and $l+1$ respectively (i.e. in the direction of input to output), rather than the opposite. However, this notation makes more sense when you add the bias.</p>
<p>As you can observe in the figure above &#8211; the (+1) bias is connected to each of the nodes in the subsequent layer. So the bias in layer 1 is connected to the all the nodes in layer two. Because the bias is not a true node with an activation function, it has no inputs (it always outputs the value +1). The notation of the bias weight is ${b_i}^{(l)}$, where *i* is the node number in the layer $l+1$ &#8211; the same as used for the normal weight notation ${w_{21}}^{(1)}$. So, the weight on the connection between the bias in layer 1 and the second node in layer 2 is given by ${b_2}^{(1)}$.</p>
<p>Remember, these values &#8211; ${w_{ji}}^{(1)}$ and ${b_i}^{(l)}$ &#8211; all need to be calculated in the training phase of the ANN.</p>
<p>Finally, the node output notation is ${h_j}^{(l)}$, where $j$ denotes the node number in layer $l$ of the network. As can be observed in the three layer network above, the output of node 2 in layer 2 has the notation of ${h_2}^{(2)}$.</p>
<p>Now that we have the notation all sorted out, it is now time to look at how you calculate the output of the network when the input and the weights are known. The process of calculating the output of the neural network given these values is called the <em>feed-forward</em> pass or process.</p>
<h2 id="the-feed-forward-pass">3 The feed-forward pass</h2>
<p>To demonstrate how to calculate the output from the input in neural networks, let&#8217;s start with the specific case of the three layer neural network that was presented above. Below it is presented in equation form, then it will be demonstrated with a concrete example and some Python code:</p>
<p>\begin{align}<br />
h_1^{(2)} &amp;= f(w_{11}^{(1)}x_1 + w_{12}^{(1)} x_2 + w_{13}^{(1)} x_3 + b_1^{(1)}) \\<br />
h_2^{(2)} &amp;= f(w_{21}^{(1)}x_1 + w_{22}^{(1)} x_2 + w_{23}^{(1)} x_3 + b_2^{(1)}) \\<br />
h_3^{(2)} &amp;= f(w_{31}^{(1)}x_1 + w_{32}^{(1)} x_2 + w_{33}^{(1)} x_3 + b_3^{(1)}) \\<br />
h_{W,b}(x) &amp;= h_1^{(3)} = f(w_{11}^{(2)}h_1^{(2)} + w_{12}^{(2)} h_2^{(2)} + w_{13}^{(2)} h_3^{(2)} + b_1^{(2)})<br />
\end{align}</p>
<p>In the equation above $f(\bullet)$ refers to the node activation function, in this case the sigmoid function. The first line, ${h_1}^{(2)}$ is the output of the first node in the second layer, and its inputs are $w_{11}^{(1)}x_1$, $w_{12}^{(1)} x_2$, $w_{13}^{(1)}x_3$ and $b_1^{(1)}$. These inputs can be traced in the three-layer connection diagram above. They are simply summed and then passed through the activation function to calculate the output of the first node. Likewise, for the other two nodes in the second layer.</p>
<p>The final line is the output of the only node in the third and final layer, which is ultimate output of the neural network. As can be observed, rather than taking the weighted input variables ($x_1, x_2, x_3$), the final node takes as input the weighted output of the nodes of the second layer ($h_{1}^{(2)}$, $h_{2}^{(2)}$, $h_{3}^{(2)}$), plus the weighted bias. Therefore, you can see in equation form the hierarchical nature of artificial neural networks.</p>
<h3 id="a-feed-forward-example">3.1 A feed-forward example</h3>
<p>Now, let&#8217;s do a simple first example of the output of this neural network in Python. First things first, notice that the weights between layer 1 and 2 ($w_{11}^{(1)}, w_{12}^{(1)}, \dots$) are ideally suited to matrix representation? Observe:</p>
<p>\begin{equation}<br />
W^{(1)} =<br />
\begin{pmatrix}<br />
w_{11}^{(1)} &amp; w_{12}^{(1)} &amp; w_{13}^{(1)} \\<br />
w_{21}^{(1)} &amp; w_{22}^{(1)} &amp; w_{23}^{(1)} \\<br />
w_{31}^{(1)} &amp; w_{32}^{(1)} &amp; w_{33}^{(1)} \\<br />
\end{pmatrix}<br />
\end{equation}</p>
<p>This matrix can be easily represented using numpy arrays:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">import numpy as np
w1 = np.array([[0.2, 0.2, 0.2], [0.4, 0.4, 0.4], [0.6, 0.6, 0.6]])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Here I have just filled up the layer 1 weight array with some example weights. We can do the same for the layer 2 weight array:</p>
<p>\begin{equation}<br />
W^{(2)} =<br />
\begin{pmatrix}<br />
w_{11}^{(2)} &amp; w_{12}^{(2)} &amp; w_{13}^{(2)}<br />
\end{pmatrix}<br />
\end{equation}</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">w2 = np.zeros((1, 3))
w2[0,:] = np.array([0.5, 0.5, 0.5])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>We can also setup some dummy values in the layer 1 bias weight array/vector, and the layer 2 bias weight (which is only a single value in this neural network structure &#8211; i.e. a scalar):</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">b1 = np.array([0.8, 0.8, 0.8])
b2 = np.array([0.2])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Finally, before we write the main program to calculate the output from the neural network, it&#8217;s handy to setup a separate Python function for the activation function:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def f(x):
    return 1 / (1 + np.exp(-x))</code></pre> <div class="code-embed-infos"> </div> </div>
<h3 id="first-attempt-feed-forward">3.2 Our first attempt at a feed-forward function</h3>
<p>Below is a simple way of calculating the output of the neural network, using nested loops in python.  We&#8217;ll look at more efficient ways of calculating the output shortly.<!--?prettify linenums=true?--></p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def simple_looped_nn_calc(n_layers, x, w, b):
    for l in range(n_layers-1):
        #Setup the input array which the weights will be multiplied by for each layer
        #If it&#039;s the first layer, the input array will be the x input vector
        #If it&#039;s not the first layer, the input to the next layer will be the 
        #output of the previous layer
        if l == 0:
            node_in = x
        else:
            node_in = h
        #Setup the output array for the nodes in layer l + 1
        h = np.zeros((w[l].shape[0],))
        #loop through the rows of the weight array
        for i in range(w[l].shape[0]):
            #setup the sum inside the activation function
            f_sum = 0
            #loop through the columns of the weight array
            for j in range(w[l].shape[1]):
                f_sum += w[l][i][j] * node_in[j]
            #add the bias
            f_sum += b[l][i]
            #finally use the activation function to calculate the
            #i-th output i.e. h1, h2, h3
            h[i] = f(f_sum)
    return h</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This function takes as input the number of layers in the neural network, the x input array/vector, then Python tuples or lists of the weights and bias weights of the network, with each element in the tuple/list representing a layer $l$ in the network.  In other words, the inputs are setup in the following:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">w = [w1, w2]
b = [b1, b2]
#a dummy x input vector
x = [1.5, 2.0, 3.0]</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The function first checks what the input is to the layer of nodes/weights being considered. If we are looking at the first layer, the input to the second layer nodes is the input vector $x$ multiplied by the relevant weights. After the first layer though, the inputs to subsequent layers are the output of the previous layers. Finally, there is a nested loop through the relevant $i$ and $j$ values of the weight vectors and the bias. The function uses the dimensions of the weights for each layer to figure out the number of nodes and therefore the structure of the network.</p>
<p>Calling the function:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">simple_looped_nn_calc(3, x, w, b)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>gives the output of 0.8354.  We can confirm this results by manually performing the calculations in the original equations:</p>
<p>\begin{align}<br />
h_1^{(2)} &amp;= f(0.2*1.5 + 0.2*2.0 + 0.2*3.0 + 0.8) = 0.8909 \\<br />
h_2^{(2)} &amp;= f(0.4*1.5 + 0.4*2.0 + 0.4*3.0 + 0.8) = 0.9677 \\<br />
h_3^{(2)} &amp;= f(0.6*1.5 + 0.6*2.0 + 0.6*3.0 + 0.8) = 0.9909 \\<br />
h_{W,b}(x) &amp;= h_1^{(3)} = f(0.5*0.8909 + 0.5*0.9677 + 0.5*0.9909 + 0.2) = 0.8354<br />
\end{align}</p>
<h3 id="more-efficient-implementation">3.3 A more efficient implementation</h3>
<p>As was stated earlier &#8211; using loops isn&#8217;t the most efficient way of calculating the feed forward step in Python. This is because the loops in Python are notoriously slow. An alternative, more efficient mechanism of doing the feed forward step in Python and numpy will be discussed shortly. We can benchmark how efficient the algorithm is by using the %timeit function in IPython, which runs the function a number of times and returns the average time that the function takes to run:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">%timeit simple_looped_nn_calc(3, x, w, b)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Running this tells us that the looped feed forward takes $40\mu s$. A result in the tens of microseconds sounds very fast, but when applied to very large practical NNs with 100s of nodes per layer, this speed will become prohibitive, especially when training the network, as will become clear later in this tutorial.  If we try a four layer neural network using the same code, we get significantly worse performance &#8211; $70\mu s$ in fact.</p>
<h3 id="vectorisation">3.4 Vectorisation in neural networks</h3>
<p>There is a way to write the equations even more compactly, and to calculate the feed forward process in neural networks more efficiently, from a computational perspective.  Firstly, we can introduce a new variable $z_{i}^{(l)}$ which is the summated input into node $i$ of layer $l$, including the bias term.  So in the case of the first node in layer 2, $z$ is equal to:</p>
<p>$$z_{1}^{(2)} = w_{11}^{(1)}x_1 + w_{12}^{(1)} x_2 + w_{13}^{(1)} x_3 + b_1^{(1)} = \sum_{j=1}^{n} w_{ij}^{(1)}x_i + b_{i}^{(1)}$$</p>
<p>where n is the number of nodes in layer 1.  Using this notation, the unwieldy previous set of equations for the example three layer network can be reduced to:</p>
<p>\begin{align}<br />
z^{(2)} &amp;= W^{(1)} x + b^{(1)} \\<br />
h^{(2)} &amp;= f(z^{(2)}) \\<br />
z^{(3)} &amp;= W^{(2)} h^{(2)} + b^{(2)} \\<br />
h_{W,b}(x) &amp;= h^{(3)} = f(z^{(3)})<br />
\end{align}</p>
<p>Note the use of capital W to denote the matrix form of the weights.  It should be noted that all of the elements in the above equation are now matrices / vectors.  If you&#8217;re unfamiliar with these concepts, they will be explained more fully in the next section. Can the above equation be simplified even further?  Yes, it can.  We can forward propagate the calculations through any number of layers in the neural network by generalising:</p>
<p>\begin{align}<br />
z^{(l+1)} &amp;= W^{(l)} h^{(l)} + b^{(l)}   \\<br />
h^{(l+1)} &amp;= f(z^{(l+1)})<br />
\end{align}</p>
<p>Here we can see the general feed forward process, where the output of layer $l$ becomes the input to layer $l+1$. We know that $h^{(1)}$ is simply the input layer $x$ and $h^{(n_l)}$ (where $n_l$ is the number of layers in the network) is the output of the output layer. Notice in the above equations that we have dropped references to the node numbers $i$ and $j$ &#8211; how can we do this? Don&#8217;t we still have to loop through and calculate all the various node inputs and outputs?</p>
<p>The answer is that we can use matrix multiplications to do this more simply. This process is called &#8220;vectorisation&#8221; and it has two benefits &#8211; first, it makes the code less complicated, as you will see shortly. Second, we can use fast linear algebra routines in Python (and other languages) rather than using loops, which will speed up our programs. Numpy can handle these calculations easily. First, for those who aren&#8217;t familiar with matrix operations, the next section is a brief recap.</p>
<h3 id="matrix-mult">3.5 Matrix multiplication</h3>
<p>Let&#8217;s expand out $z^{(l+1)} = W^{(l)} h^{(l)} + b^{(l)}$ in explicit matrix/vector form for the input layer (i.e. $h^{(l)} = x$):</p>
<p>\begin{align}<br />
z^{(2)} &amp;=<br />
\begin{pmatrix}<br />
w_{11}^{(1)} &amp; w_{12}^{(1)} &amp; w_{13}^{(1)} \\<br />
w_{21}^{(1)} &amp; w_{22}^{(1)} &amp; w_{23}^{(1)} \\<br />
w_{31}^{(1)} &amp; w_{32}^{(1)} &amp; w_{33}^{(1)} \\<br />
\end{pmatrix}<br />
\begin{pmatrix}<br />
x_{1} \\<br />
x_{2} \\<br />
x_{3} \\<br />
\end{pmatrix} +<br />
\begin{pmatrix}<br />
b_{1}^{(1)} \\<br />
b_{2}^{(1)} \\<br />
b_{3}^{(1)} \\<br />
\end{pmatrix} \\<br />
&amp;=<br />
\begin{pmatrix}<br />
w_{11}^{(1)}x_{1} + w_{12}^{(1)}x_{2} + w_{13}^{(1)}x_{3} \\<br />
w_{21}^{(1)}x_{1} + w_{22}^{(1)}x_{2} + w_{23}^{(1)}x_{3} \\<br />
w_{31}^{(1)}x_{1} + w_{32}^{(1)}x_{2} + w_{33}^{(1)}x_{3} \\<br />
\end{pmatrix} +<br />
\begin{pmatrix}<br />
b_{1}^{(1)} \\<br />
b_{2}^{(1)} \\<br />
b_{3}^{(1)} \\<br />
\end{pmatrix} \\<br />
&amp;=<br />
\begin{pmatrix}<br />
w_{11}^{(1)}x_{1} + w_{12}^{(1)}x_{2} + w_{13}^{(1)}x_{3} + b_{1}^{(1)} \\<br />
w_{21}^{(1)}x_{1} + w_{22}^{(1)}x_{2} + w_{23}^{(1)}x_{3} + b_{2}^{(1)} \\<br />
w_{31}^{(1)}x_{1} + w_{32}^{(1)}x_{2} + w_{33}^{(1)}x_{3} + b_{3}^{(1)} \\<br />
\end{pmatrix} \\<br />
\end{align}</p>
<p>For those who aren&#8217;t aware of how matrix multiplication works, it is a good idea to scrub up on matrix operations. There are many <a href="http://stattrek.com/tutorials/matrix-algebra-tutorial.aspx" target="_blank" rel="noopener noreferrer">sites</a> which cover this well. However, just quickly, when the weight matrix is multiplied by the input layer vector, each element in the $row$ of the weight matrix is multiplied by each element in the single $column$ of the input vector, then summed to create a new (3 x 1) vector. Then you can simply add the bias weights vector to achieve the final result.</p>
<p>You can observe how each row of the final result above corresponds to the argument of the activation function in the original non-matrix set of equations above. If the activation function is capable of being applied element-wise (i.e. to each row separately in the $z^{(1)}$ vector), then we can do all our calculations using matrices and vectors rather than slow Python loops. Thankfully, numpy allows us to do just that, with reasonably fast matrix operations and element-wise functions. Let&#8217;s have a look at a much more simplified (and faster) version of the simple_looped_nn_calc:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def matrix_feed_forward_calc(n_layers, x, w, b):
    for l in range(n_layers-1):
        if l == 0:
            node_in = x
        else:
            node_in = h
        z = w[l].dot(node_in) + b[l]
        h = f(z)
    return h</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Note line 7  where the matrix multiplication occurs &#8211; if you just use the $*$ symbol when multiplying the weights by the node input vector in numpy it will attempt to perform some sort of element-wise multiplication, rather than the true matrix multiplication that we desire. Therefore you need to use the <em>a.dot(b)</em> notation when performing matrix multiplication in numpy.</p>
<p>If we perform %timeit again using this new function and a simple 4 layer network, we only get an improvement of $24\mu s$ (a reduction from $70\mu s$ to $46\mu s$).  However, if we increase the size of the 4 layer network to layers of 100-100-50-10 nodes the results are much more impressive.  The Python looped based method takes a whopping $41ms$ &#8211; note, that is milliseconds, and the vectorised implementation only takes $84\mu s$ to forward propagate through the neural network.  By using vectorised calculations instead of Python loops we have increased the efficiency of the calculation 500 fold! That&#8217;s a huge improvement. There is even the possibility of faster implementations of matrix operations using deep learning packages such as <a href="https://www.tensorflow.org/" target="_blank" rel="noopener noreferrer">TensorFlow</a> and <a href="http://www.deeplearning.net/software/theano/" target="_blank" rel="noopener noreferrer">Theano</a> which utilise your computer&#8217;s GPU (rather than the CPU), the architecture of which is more suited to fast matrix computations  (I have a <a href="http://adventuresinmachinelearning.com/python-tensorflow-tutorial/" target="_blank" rel="noopener noreferrer">TensorFlow tutorial </a>post also).</p>
<p>That brings us to an end of the feed-forward introduction for neural networks.  The next section will deal with how to actually train a neural network so that it can perform classification tasks, using gradient descent and backpropagation.</p>
<h2 id="gradient-desc-opt">4 Gradient descent and optimisation</h2>
<p>As mentioned in <a href="#what-are-anns">Section 1</a>, the setting of the values of the weights which link the layers in the network is what constitutes the training of the system. In supervised learning, the idea is to reduce the <em>error</em> between the input and the desired output. So if we have a neural network with one output layer, and given some input $x$ we want the neural network to output a 2, yet the network actually produces a 5, a simple expression of the <em>error</em> is $abs(2-5)=3$. For the mathematically minded, this would be the $L^1$ norm of the error (don&#8217;t worry about it if you don&#8217;t know what this is).</p>
<p>The idea of supervised learning is to provide many input-output pairs of known data and vary the weights based on these samples so that the error expression is minimised. We can specify these input-output pairs as $\{ (x^{(1)}, y^{(1)}), \ldots, (x^{(m)}, y^{(m)}) \}$ where $m$ is the number of training samples that we have on hand to train the weights of the network. Each of these inputs or outputs can be vectors &#8211; that is $x^{(1)}$ is not necessarily just one value, it could be an $N$ dimensional series of values. For instance, let&#8217;s say that we&#8217;re training a spam-detection neural network &#8211; in such a case $x^{(1)}$ could be a count of all the different significant words in an e-mail e.g.:</p>
<p>\begin{align}<br />
x^{(1)} &amp;=<br />
\begin{pmatrix}<br />
No. of &#8220;prince&#8221; \\<br />
No. of &#8220;nigeria&#8221; \\<br />
No. of &#8220;extension&#8221; \\<br />
\vdots \\<br />
No. of &#8220;mum&#8221; \\<br />
No. of &#8220;burger&#8221; \\<br />
\end{pmatrix} \\<br />
&amp;=<br />
\begin{pmatrix}<br />
2 \\<br />
2 \\<br />
0 \\<br />
\vdots \\<br />
0 \\<br />
1 \\<br />
\end{pmatrix}<br />
\end{align}</p>
<p>$y^{(1)}$ in this case could be a single scalar value, either a 1 or a 0 to designate whether the e-mail is spam or not. Or, in other applications it could be a $K$ dimensional vector. As an example, say we have input $x$ that is a vector of the pixel greyscale readings of a photograph.  We also have an output $y$ that is a 26 dimensional vector that designates, with a 1 or 0, what letter of the alphabet is shown in the photograph i.e. $(1, 0, \ldots, 0)$ for a, $(0, 1, \ldots, 0)$ for b and so on.  This 26 dimensional output vector could be used to classify letters in photographs.</p>
<p>In training the network with these $(x, y)$ pairs, the goal is to get the neural network better and better at predicting the correct $y$ given $x$. This is performed by varying the weights so as to minimize the error. How do we know how to vary the weights, given an error in the output of the network? This is where the concept of <strong><em>gradient descent</em></strong> comes in handy. Consider the diagram below:</p>
<p>&nbsp;</p>
<figure id="attachment_74" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-74 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Gradient-descent-300x156.jpg" alt="" width="300" height="156" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Gradient-descent-300x156.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Gradient-descent.jpg 553w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 8. Simple, one-dimensional gradient descent</figcaption></figure>
<p>In this diagram we have a blue plot of the error depending on a single scalar weight value, $w$. The minimum possible error is marked by the black cross, but we don&#8217;t know what $w$ value gives that minimum error. We start out at a random value of $w$, which gives an error marked by the red dot on the curve labelled with &#8220;1&#8221;. We need to change $w$ in a way to approach that minimum possible error, the black cross. One of the most common ways of approaching that value is called <strong><em>gradient descent</em></strong>.</p>
<p>To proceed with this method, first the gradient of the error with respect to $w$ is calculated at point &#8220;1&#8221;. For those who don&#8217;t know, the <em>gradient</em> is the slope of the error curve at that point. It is shown in the diagram above by the black arrow which &#8220;pierces&#8221; point &#8220;1&#8221;. The gradient also gives directional information &#8211; if it is positive with respect to an increase in $w$, a step in that <em>direction</em> will lead to an increase in the error. If it is negative with respect to an <em>increase</em> in $w$ (as it is in the diagram above), a step in that will lead to a <em>decrease</em> in the error. Obviously, we wish to make a step in $w$ that will lead to a decrease in the error. The magnitude of the <em>gradient</em> or the &#8220;steepness&#8221; of the slope, gives an indication of how fast the error curve or function is changing at that point. The higher the magnitude of the gradient, the faster the error is changing at that point with respect to $w$.</p>
<p>The gradient descent method uses the gradient to make an informed step change in $w$ to lead it towards the minimum of the error curve. This is an <em>iterative</em> method, that involves multiple steps. Each time, the $w$ value is updated according to:</p>
<p>\begin{equation}<br />
w_{new} = w_{old} &#8211; \alpha * \nabla error<br />
\end{equation}</p>
<p>Here $w_{new}$ denotes the new $w$ position, $w_{old}$ denotes the current or old $w$ position, $\nabla error$ is the gradient of the error at $w_{old}$ and $\alpha$ is the step size. The step size $\alpha$ will determine how quickly the solution converges on the minimum error. However, this parameter has to be tuned &#8211; if it is too large, you can imagine the solution bouncing around on either side of the minimum in the above diagram. This will result in an optimisation of $w$ that does not converge. As this iterative algorithm approaches the minimum, the gradient or change in the error with each step will reduce. You can see in the graph above that the gradient lines will &#8220;flatten out&#8221; as the solution point approaches the minimum. As the solution approaches the minimum error, because of the decreasing gradient, it will result in only small improvements to the error.  When the solution approaches this &#8220;flattening&#8221; out of the error we want to exit the iterative process.  This exit can be performed by either stopping after a certain number of iterations or via some sort of &#8220;stop condition&#8221;.  This stop condition might be when the change in the error drops below a certain limit, often called the <em>precision</em>.</p>
<h3 id="simple-example">4.1 A simple example in code</h3>
<p>Below is an example of a simple Python implementation of gradient descent for solving the minimum of the equation $f(x) = x^4 &#8211; 3x^3 + 2$ taken from <a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener noreferrer">Wikipedia.</a>  The gradient of this function is able to be calculated analytically (i.e. we can do it easily using calculus, which we can&#8217;t do with many real world applications) and is $f'(x) = 4x^3 &#8211; 9x^2$. This means at every value of $x$, we can calculate the gradient of the function by using a simple equation. Again, using calculus we can know that the exact minimum of this equation is $x = 2.25$ .</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">x_old = 0 # The value does not matter as long as abs(x_new - x_old) &gt; precision
x_new = 6 # The algorithm starts at x=6
gamma = 0.01 # step size
precision = 0.00001

def df(x):
    y = 4 * x**3 - 9 * x**2
    return y

while abs(x_new - x_old) &gt; precision:
    x_old = x_new
    x_new += -gamma * df(x_old)

print(&quot;The local minimum occurs at %f&quot; % x_new)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This function prints &#8220;The local minimum occurs at 2.249965&#8221;, which agrees with the exact solution within the precision.  This code implements the weight adjustment algorithm that I showed above, and can be seen to find the minimum of the function correctly within the given precision. This is a very simple example of gradient descent, and finding the gradient works quite differently when training neural networks. However, the main idea remains &#8211; we figure out the gradient of the neural network then adjust the weights in a step to try to get closer to the minimum error that we are trying to find. Another difference between this toy example of gradient descent is that the weight vector is multi-dimensional, and therefore the gradient descent method must search a multi-dimensional space for the minimum point.</p>
<p>The way we figure out the gradient of a neural network is via the famous <em><strong>backpropagation</strong></em> method, which will be discussed shortly. First however, we have to look at the error function more closely.</p>
<h3 id="the-cost-function">4.2 The cost function</h3>
<p>Previously, we&#8217;ve talked about iteratively minimising the error of the output of the neural network by varying the weights in gradient descent. However, as it turns out, there is a mathematically more generalised way of looking at things that allows us to reduce the error while also preventing things like <em>overfitting</em> (this will be discussed more in later articles). This more general optimisation formulation revolves around minimising what&#8217;s called the <strong><em>cost function</em></strong>. The equivalent cost function of a single training pair ($x^z$, $y^z$) in a neural network is:</p>
<p>\begin{align}<br />
J(w,b,x,y) &amp;= \frac{1}{2} \parallel y^z &#8211; h^{(n_l)}(x^z) \parallel ^2 \\<br />
&amp;= \frac{1}{2} \parallel y^z &#8211; y_{pred}(x^z) \parallel ^2<br />
\end{align}</p>
<p>This shows the cost function of the $z_{th}$ training sample, where $h^{(n_l)}$ is the output of the final layer of the neural network i.e. the output of the neural network. I&#8217;ve also represented $h^{(n_l)}$ as $y_{pred}$ to highlight the prediction of the neural network given $x^z$. The two vertical lines represent the $L^2$ norm of the error, or what is known as the sum-of-squares error (SSE). SSE is a very common way of representing the error of a machine learning system. Instead of taking just the absolute error $abs(y_{pred}(x^z) &#8211; y^z)$, we use the square of the error. There are many reasons why the SSE is often used which will not be discussed here &#8211; suffice to say that this is a very common way of representing the errors in machine learning. The $\frac{1}{2}$ out the front is just a constant added that tidies things up when we differentiate the cost function, which we&#8217;ll be doing when we perform backpropagation.</p>
<p>Note that the formulation for the cost function above is for a single $(x,y)$ training pair. We want to minimise the cost function over all of our $m$ training pairs. Therefore, we want to find the minimum *mean squared error* (MSE) over all the training samples:</p>
<p>\begin{align}<br />
J(w,b) &amp;= \frac{1}{m} \sum_{z=0}^m \frac{1}{2} \parallel y^z &#8211; h^{(n_l)}(x^z) \parallel ^2 \\<br />
&amp;= \frac{1}{m} \sum_{z=0}^m J(W, b, x^{(z)}, y^{(z)})<br />
\end{align}</p>
<p>So, how do you use the cost function $J$ above to train the weights of our network? Using gradient descent and backpropagation. First, let&#8217;s look at gradient descent more closely in neural networks.</p>
<h3 id="gradient-descent-in-nn">4.3 Gradient descent in neural networks</h3>
<p>Gradient descent for every weight $w_{(ij)}^{(l)}$ and every bias $b_i^{(l)}$ in the neural network looks like the following:</p>
<p>\begin{align}<br />
w_{ij}^{(l)} &amp;= w_{ij}^{(l)} &#8211; \alpha \frac{\partial}{\partial w_{ij}^{(l)}} J(w,b) \\<br />
b_{i}^{(l)} &amp;= b_{i}^{(l)} &#8211; \alpha \frac{\partial}{\partial b_{i}^{(l)}} J(w,b)<br />
\end{align}</p>
<p>Basically, the equation above is similiar to the previously shown gradient descent algorithm: $w_{new} = w_{old} &#8211; \alpha * \nabla error$. The new and old subscripts are missing, but the values on the left side of the equation are <em>new</em> and the values on the right side are <em>old</em>. Again, we have an iterative process whereby the weights are updated in each iteration, this time based on the cost function $J(w,b)$.</p>
<p>The values $\frac{\partial}{\partial w_{ij}^{(l)}}$ and $\frac{\partial}{\partial b_{i}^{(l)}}$ are the <em>partial derivatives </em>of the single sample cost function based on the weight values. What does this mean? Recall that for the simple gradient descent example mentioned previously, each step depends on the <em>slope</em> of the error/cost term with respect to the weights. Another word for slope or gradient is the <em>derivative</em>. A normal derivative has the notation $\frac{d}{dx}$. If $x$ in this instance is a vector, then such a derivative will also be a vector, displaying the gradient in all the dimensions of $x$.</p>
<h3 id="two-dimensional">4.4 A two dimensional gradient descent example</h3>
<p>Let&#8217;s take the example of a standard two-dimensional gradient descent problem. Below is a diagram of an iterative two-dimensional gradient descent run:</p>
<figure id="attachment_81" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-81 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Two-dimensional-gradient-descent-300x203.jpg" alt="" width="300" height="203" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Two-dimensional-gradient-descent-300x203.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Two-dimensional-gradient-descent.jpg 471w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 9. Two-dimensional gradient descent</figcaption></figure>
<p>The blue lines in the above diagram are the contour lines of the cost function &#8211; designating regions with an error value that is approximately the same. As can be observed in the diagram above, each step ($p_1 \to p_2 \to p_3$) in the gradient descent involves a gradient or derivative that is an arrow/vector.  This vector spans both the $[x_1, x_2]$ dimensions, as the solution works its way towards the minimum in the centre. So, for instance, the derivative evaluated at $p_1$ might be $\frac {d}{dx} = [2.1, 0.7]$, where the derivative is a vector to designate the two directions. The <em>partial</em> derivative $\frac {\partial}{\partial x_1}$ in this case would be a scalar $\to [2.1]$ &#8211; in other words, it is the gradient in only one direction of the search space ($x_1$). In gradient descent, it is often the case that the partial derivative of all the possible search directions are calculated, then &#8220;gathered up&#8221; to determine a new, complete, step direction.</p>
<p>In neural networks, we don&#8217;t have a simple cost function where we can easily evaluate the gradient, like we did in our toy gradient descent example ($f(x) = x^4 &#8211; 3x^3 + 2$). In fact, things are even trickier. While we can compare the output of the neural network to our expected training value, $y^{(z)}$ and feasibly look at how changing the weights of the output layer would change the cost function for the sample (i.e. calculating the gradient), how on earth do we do that for all the <em>hidden</em> layers of the network?</p>
<p>The answer to that is the backpropagation method. This method allows us to &#8220;share&#8221; the cost function or error to all the weights in the network &#8211; or in other words, it allows us to determine how much of the error is caused by any given weight.</p>
<h3 id="backprop-in-depth">4.5 Backpropagation in depth</h3>
<p>In this section, I&#8217;m going to delve into the maths a little. If you&#8217;re wary of the maths of how backpropagation works, then it may be best to skip this section.  The next <a href="#implementing-nn">section</a> will show you how to implement backpropagation in code &#8211; so if you want to skip straight on to using this method, feel free to skip the rest of this section. However, if you don&#8217;t mind a little bit of maths, I encourage you to push on to the end of this section as it will give you a good depth of understanding in training neural networks. This will be invaluable to understanding some of the key ideas in deep learning, rather than just being a code cruncher who doesn&#8217;t really understand how the code works.</p>
<p>First let&#8217;s recall some of the foundational equations from <a href="#the-feed-forward-pass">Section 3</a> for the following three layer neural network:</p>
<figure id="attachment_60" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-60 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network-300x158.png" alt="" width="300" height="158" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network-300x158.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Three-layer-network.png 591w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 10. Three layer neural network (again)</figcaption></figure>
<p>The output of this neural network can be calculated by:</p>
<p>\begin{equation}<br />
h_{W,b}(x) = h_1^{(3)} = f(w_{11}^{(2)}h_1^{(2)} + w_{12}^{(2)} h_2^{(2)} + w_{13}^{(2)} h_3^{(2)} + b_1^{(2)})<br />
\end{equation}</p>
<p>We can also simplify the above to $h_1^{(3)} = f(z_1^{(2)})$ by defining $z_1^{(2)}$ as:</p>
<p>$$z_{1}^{(2)} = w_{11}^{(2)}h_1^{(2)} + w_{12}^{(2)} h_2^{(2)} + w_{13}^{(2)} h_3^{(2)} + b_1^{(2)}$$</p>
<p>Let&#8217;s say we want to find out how much a change in the weight $w_{12}^{(2)}$ has on the cost function $J$. This is to evaluate $\frac {\partial J}{\partial w_{12}^{(2)}}$. To do so, we have to use something called the chain function:</p>
<p>$$\frac {\partial J}{\partial w_{12}^{(2)}} = \frac {\partial J}{\partial h_1^{(3)}} \frac {\partial h_1^{(3)}}{\partial z_1^{(2)}} \frac {\partial z_1^{(2)}}{\partial w_{12}^{(2)}}$$</p>
<p>If you look at the terms on the right &#8211; the numerators &#8220;cancel out&#8221; the denominators, in the same way that $\frac {2}{5} \frac {5}{2} = \frac {2}{2} = 1$. Therefore we can construct $\frac {\partial J}{\partial w_{12}^{(2)}}$ by stringing together a few partial derivatives (which are quite easy, thankfully). Let&#8217;s start with $\frac {\partial z_1^{(2)}}{\partial w_{12}^{(2)}}$:</p>
<p>\begin{align}<br />
\frac {\partial z_1^{(2)}}{\partial w_{12}^{(2)}} &amp;= \frac {\partial}{\partial w_{12}^{(2)}} (w_{11}^{(1)}h_1^{(2)} + w_{12}^{(1)} h_2^{(2)} + w_{13}^{(1)} h_3^{(2)} + b_1^{(1)})\\<br />
&amp;= \frac {\partial}{\partial w_{12}^{(2)}} (w_{12}^{(1)} h_2^{(2)})\\<br />
&amp;= h_2^{(2)}<br />
\end{align}</p>
<p>The partial derivative of $z_1^{(2)}$ with respect $w_{12}^{(2)}$ only operates on one term within the parentheses, $w_{12}^{(1)} h_2^{(2)}$, as all the other terms don&#8217;t vary at all when $w_{12}^{(2)}$ does. The derivative of a constant is 1, therefore $\frac {\partial}{\partial w_{12}^{(2)}} (w_{12}^{(1)} h_2^{(2)})$ collapses to just $h_2^{(2)}$, which is simply the output of the second node in layer 2.</p>
<p>The next partial derivative in the chain is $\frac {\partial h_1^{(3)}}{\partial z_1^{(2)}}$, which is the partial derivative of the activation function of the $h_1^{(3)}$ output node. Because of the requirement to be able to derive this derivative, the activation functions in neural networks need to be <em>differentiable</em>. For the common sigmoid activation function (shown in <a href="#the-artificial-neuron">Section 2.1</a>), the derivative is:</p>
<p>$$\frac {\partial h}{\partial z} = f'(z) = f(z)(1-f(z))$$</p>
<p>Where $f(z)$ is the activation function. So far so good &#8211; now we have to work out how to deal with the first term $\frac {\partial J}{\partial h_1^{(3)}}$. Remember that $J(w,b,x,y)$ is the mean squared error loss function, which looks like (for our case):</p>
<p>$$J(w,b,x,y) = \frac{1}{2} \parallel y_1 &#8211; h_1^{(3)}(z_1^{(2)}) \parallel ^2$$</p>
<p>Here $y_1$ is the training target for the output node. Again using the chain rule:</p>
<p>\begin{align}<br />
&amp;Let\ u = \parallel y_1 &#8211; h_1^{(3)}(z_1^{(2)}) \parallel\ and\ J = \frac {1}{2} u^2\\<br />
&amp;Using\ \frac {\partial J}{\partial h} = \frac {\partial J}{\partial u} \frac {\partial u}{\partial h}:\\<br />
&amp;\frac {\partial J}{\partial h} = -(y_1 &#8211; h_1^{(3)})<br />
\end{align}</p>
<p>So we&#8217;ve now figured out how to calculate $\frac {\partial J}{\partial w_{12}^{(2)}}$, at least for the weights connecting the output layer. Before we move to any hidden layers (i.e. layer 2 in our example case), let&#8217;s introduce some simplifications to tighten up our notation and introduce $\delta$:</p>
<p>$$\delta_i^{(n_l)} = -(y_i &#8211; h_i^{(n_l)})\cdot f^\prime(z_i^{(n_l)})$$</p>
<p>Where $i$ is the node number of the output layer. In our selected example there is only one such layer, therefore $i=1$ always in this case. Now we can write the complete cost function derivative as:</p>
<p>\begin{align}<br />
\frac{\partial}{\partial W_{ij}^{(l)}} J(W,b,x, y) &amp;= h^{(l)}_j \delta_i^{(l+1)} \\<br />
\end{align}</p>
<p>Where, for the output layer in our case, $l$ = 2 and $i$ remains the node number.</p>
<h3 id="prop-in-hidden-layers">4.6 Propagating into the hidden layers</h3>
<p>What about for weights feeding into any hidden layers (layer 2 in our case)? For the weights connecting the output layer, the $\frac {\partial J}{\partial h} = -(y_i &#8211; h_i^{(n_l)})$ derivative made sense, as the cost function can be directly calculated by comparing the output layer to the training data. The output of the hidden nodes, however, have no such direct reference, rather, they are connected to the cost function only through mediating weights and potentially other layers of nodes. How can we find the variation in the cost function from changes to weights embedded deep within the neural network? As mentioned previously, we use the <em>backpropagation</em> method.</p>
<p>Now that we&#8217;ve done the hard work using the chain rule, we&#8217;ll now take a more graphical approach. The term that needs to propagate back through the network is the $\delta_i^{(n_l)}$ term, as this is the network&#8217;s ultimate connection to the cost function. What about node j in the second layer (hidden layer)? How does it contribute to $\delta_i^{(n_l)}$ in our test network? It contributes via the weight $w_{ij}^{(2)}$ &#8211; see the diagram below for the case of $j=1$ and $i=1$.</p>
<figure id="attachment_83" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-83 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration-300x204.jpg" alt="" width="300" height="204" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration-300x204.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration.jpg 446w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 11. Simple backpropagation illustration</figcaption></figure>
<p>As can be observed from above, the output layer $\delta$ is <em>communicated</em> to the hidden node by the weight of the connection. In the case where there is only one output layer node, the generalised hidden layer $\delta$ is defined as:</p>
<p>$$\delta_j^{(l)} = \delta_1^{(l+1)} w_{1j}^{(l)}\ f^\prime(z_j)^{(l)}$$</p>
<p>Where $j$ is the node number in layer $l$. What about the case where there are multiple output nodes? In this case, the weighted sum of all the communicated errors are taken to calculate $\delta_j^{(l)}$, as shown in the diagram below:</p>
<figure id="attachment_84" style="width: 300px" class="wp-caption aligncenter"><img class="wp-image-84 size-medium" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration-with-multiple-outputs-300x242.jpg" alt="" width="300" height="242" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration-with-multiple-outputs-300x242.jpg 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Backpropagation-illustration-with-multiple-outputs.jpg 448w" sizes="(max-width: 300px) 100vw, 300px" /><figcaption class="wp-caption-text">Figure 12. Backpropagation illustration with multiple outputs</figcaption></figure>
<p>As can be observed from the above, each $\delta$ value from the output layer is included in the sum used to calculate $\delta_1^{(2)}$, but each output $\delta$ is weighted according to the appropriate $w_{i1}^{(2)}$ value. In other words, node 1 in layer 2 contributes to the error of three output nodes, therefore the measured error (or cost function value) at each of these nodes has to be &#8220;passed back&#8221; to the $\delta$ value for this node. Now we can develop a generalised expression for the $\delta$ values for nodes in the hidden layers:</p>
<p>$$\delta_j^{(l)} = (\sum_{i=1}^{s_{(l+1)}} w_{ij}^{(l)} \delta_i^{(l+1)})\ f^\prime(z_j^{(l)})$$</p>
<p>Where $j$ is the node number in layer $l$ and $i$ is the node number in layer $l+1$ (which is the same notation we have used from the start). The value $s_{(l+1)}$ is the number of nodes in layer $(l+1)$.</p>
<p>So we now know how to calculate: $$\frac{\partial}{\partial W_{ij}^{(l)}} J(W,b,x, y) = h^{(l)}_j \delta_i^{(l+1)}$$ as shown previously. What about the bias weights? I&#8217;m not going to derive them as I did with the normal weights in the interest of saving time / space. However, the reader shouldn&#8217;t have too many issues following the same steps, using the chain rule, to arrive at:</p>
<p>$$\frac{\partial}{\partial b_{i}^{(l)}} J(W,b,x, y) = \delta_i^{(l+1)}$$</p>
<p>Great &#8211; so we now know how to perform our original gradient descent problem for neural networks:</p>
<p>\begin{align}<br />
w_{ij}^{(l)} &amp;= w_{ij}^{(l)} &#8211; \alpha \frac{\partial}{\partial w_{ij}^{(l)}} J(w,b) \\<br />
b_{i}^{(l)} &amp;= b_{i}^{(l)} &#8211; \alpha \frac{\partial}{\partial b_{i}^{(l)}} J(w,b)<br />
\end{align}</p>
<p>However, to perform this gradient descent training of the weights, we would have to resort to loops within loops. As previously shown in <a href="#vectorisation">Section 3.4</a> of this neural network tutorial, performing such calculations in Python using loops is slow for large networks. Therefore, we need to figure out how to vectorise such calculations, which the next section will show.</p>
<h3 id="vector-backprop">4.7 Vectorisation of backpropagation</h3>
<p>To consider how to vectorise the gradient descent calculations in neural networks, let&#8217;s first look at a naïve vectorised version of the gradient of the cost function (<strong>warning</strong>: this is not in a correct form yet!):</p>
<p>\begin{align}<br />
\frac{\partial J}{\partial W^{(l)}} &amp;= h^{(l)} \delta^{(l+1)}\\<br />
\frac{\partial J}{\partial b^{(l)}} &amp;= \delta^{(l+1)}<br />
\end{align}</p>
<p>Now, let&#8217;s look at what element of the above equations. What does $h^{(l)}$ look like? Pretty simple, just a $(s_l \times 1)$ vector, where $s_l$ is the number of nodes in layer $l$. What does the multiplication of $h^{(l)} \delta^{(l+1)}$ look like? Well, because we know that $\alpha \times \frac{\partial J}{\partial W^{(l)}}$ must be the same size of the weight matrix $W^{(l)}$, we know that the outcome of $h^{(l)} \delta^{(l+1)}$ must also be the same size as the weight matrix for layer $l$. In other words it has to be of size $(s_{l+1} \times s_{l})$.</p>
<p>We know that $\delta^{(l+1)}$ has the dimension $(s_{l+1} \times 1)$ and that $h^{(l)}$ has the dimension of $(s_l \times 1)$. The rules of matrix multiplication show that a matrix of dimension $(\mathbf n \times m)$ multiplied by a matrix of dimension $(o \times \mathbf p)$ will have a product matrix of size $(\mathbf n \times \mathbf p)$. If we perform a straight multiplication between $h^{(l)}$ and $\delta^{(l+1)}$, the number of columns of the first vector (i.e. 1 column) will not equal the number of rows of the second vector (i.e. 3 rows), therefore we can&#8217;t perform a proper matrix multiplication. The only way we can get a proper outcome of size $(s_{l+1} \times s_{l})$ is by using a matrix <strong><em>transpose</em></strong>. A transpose swaps the dimensions of a matrix around e.g. a $(s_l \times 1)$ sized vector becomes a $(1 \times s_l)$ sized vector, and is denoted by a superscript of $T$. Therefore, we can do the following:</p>
<p>$$\delta^{(l+1)} (h^{(l)})^T = (s_{l+1} \times 1) \times (1 \times s_l) = (s_{l+1} \times s_l)$$</p>
<p>As can be observed below, by using the transpose operation we can arrive at the outcome we desired.</p>
<p>A final vectorisation that can be performed is during the weighted addition of the errors in the backpropagation step:</p>
<p>$$\delta_j^{(l)} = (\sum_{i=1}^{s_{(l+1)}} w_{ij}^{(l)} \delta_i^{(l+1)})\ f^\prime(z_j^{(l)}) = \left((W^{(l)})^T \delta^{(l+1)}\right) \bullet f'(z^{(l)})$$</p>
<p>The $\bullet$ symbol in the above designates an element-by-element multiplication (called the Hadamard product), not a matrix multiplication.  Note that the matrix multiplication $\left((W^{(l)})^T \delta^{(l+1)}\right)$ performs the necessary summation of the weights and $\delta$ values &#8211; the reader can check that this is the case.</p>
<h3 id="imp-gradient-desc">4.8 Implementing the gradient descent step</h3>
<p>Now, how do we integrate this new vectorisation into the gradient descent steps of our soon-to-be coded algorithm? First, we have to look again at the overall cost function we are trying to minimise (not just the sample-by-sample cost function shown in the preceding equation):</p>
<p>\begin{align}<br />
J(w,b) &amp;= \frac{1}{m} \sum_{z=0}^m J(W, b, x^{(z)}, y^{(z)})<br />
\end{align}</p>
<p>As we can observe, the total cost function is the mean of all the sample-by-sample cost function calculations. Also remember the gradient descent calculation (showing the element-by-element version along with the vectorised version):</p>
<p>\begin{align}<br />
w_{ij}^{(l)} &amp;= w_{ij}^{(l)} &#8211; \alpha \frac{\partial}{\partial w_{ij}^{(l)}} J(w,b)\\<br />
W^{(l)} &amp;= W^{(l)} &#8211; \alpha \frac{\partial}{\partial W^{(l)}} J(w,b)\\<br />
&amp;= W^{(l)} &#8211; \alpha \left[\frac{1}{m} \sum_{z=1}^{m} \frac {\partial}{\partial W^{(l)}} J(w,b,x^{(z)},y^{(z)}) \right]\\<br />
\end{align}</p>
<p>So that means as we go along through our training samples or batches, we have to have a term that is summing up the partial derivatives of the individual sample cost function calculations. This term will gather up all the values for the mean calculation. Let&#8217;s call this &#8220;summing up&#8221; term $\Delta W^{(l)}$. Likewise, the equivalent bias term can be called $\Delta b^{(l)}$. Therefore, at each sample iteration of the final training algorithm, we have to perform the following steps:</p>
<p>\begin{align}<br />
\Delta W^{(l)} &amp;= \Delta W^{(l)} + \frac {\partial}{\partial W^{(l)}} J(w,b,x^{(z)},y^{(z)})\\<br />
&amp;= \Delta W^{(l)} + \delta^{(l+1)} (h^{(l)})^T\\<br />
\Delta b^{(l)} &amp;= \Delta b^{(1)} + \delta^{(l+1)}<br />
\end{align}</p>
<p>By performing the above operations at each iteration, we slowly build up the previously mentioned sum $\sum_{z=1}^{m} \frac {\partial}{\partial W^{(l)}} J(w,b,x^{(z)},y^{(z)})$ (and the same for $b$). Once all the samples have been iterated through, and the $\Delta$ values have been summed up, we update the weight parameters :</p>
<p>\begin{align}<br />
W^{(l)} &amp;= W^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta W^{(l)} \right] \\<br />
b^{(l)} &amp;= b^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta b^{(l)}\right]
\end{align}</p>
<h3 id="final-gradient-desc-algo">4.9 The final gradient descent algorithm</h3>
<p>So, no we&#8217;ve finally made it to the point where we can specify the entire backpropagation-based gradient descent training of our neural networks. It has taken quite a few steps to show, but hopefully it has been instructive. The final backpropagation algorithm is as follows:</p>
<p>Randomly initialise the weights for each layer $W^{(l)}$<br />
While iterations &lt; iteration limit:<br />
1. Set $\Delta W$ and $\Delta b$ to zero<br />
2. For samples 1 to m:<br />
a. Perform a feed foward pass through all the $n_l$ layers. Store the activation function outputs $h^{(l)}$<br />
b. Calculate the $\delta^{(n_l)}$ value for the output layer<br />
c. Use backpropagation to calculate the $\delta^{(l)}$ values for layers 2 to $n_l-1$<br />
d. Update the $\Delta W^{(l)}$ and $\Delta b^{(l)}$ for each layer<br />
3. Perform a gradient descent step using:</p>
<p>$W^{(l)} = W^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta W^{(l)} \right]$<br />
$b^{(l)} = b^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta b^{(l)}\right]$</p>
<p>As specified in the algorithm above, we would repeat the gradient descent routine until we are happy that the average cost function has reached a minimum. At this point, our network is trained and (ideally) ready for use.</p>
<p>The next part of this neural networks tutorial will show how to implement this algorithm to train a neural network that recognises hand-written digits.</p>
<h2 id="implementing-nn">5 Implementing the neural network in Python</h2>
<p>In the last <a href="#gradient-desc-opt">section</a> we looked at the theory surrounding gradient descent training in neural networks and the backpropagation method. In this article, we are going to apply that theory to develop some code to perform training and prediction on the MNIST dataset. The MNIST dataset is a kind of go-to dataset in neural network and deep learning examples, so we&#8217;ll stick with it here too. What it consists of is a record of images of hand-written digits with associated labels that tell us what the digit is. Each image is 8 x 8 pixels in size, and the image data sample is represented by 64 data points which denote the pixel intensity. In this example, we&#8217;ll be using the MNIST dataset provided in the Python Machine Learning library called <a href="http://scikit-learn.org" target="_blank" rel="noopener noreferrer">scikit learn</a>. An example of the image (and the extraction of the data from the scikit learn dataset) is shown in the code below (for an image of 1):</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from sklearn.datasets import load_digits
digits = load_digits()
print(digits.data.shape)
import matplotlib.pyplot as plt 
plt.gray() 
plt.matshow(digits.images[1]) 
plt.show()</code></pre> <div class="code-embed-infos"> </div> </div>
<figure id="attachment_94" style="width: 254px" class="wp-caption aligncenter"><img class="size-full wp-image-94" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/MNIST-digit-one.png" alt="" width="254" height="258" /><figcaption class="wp-caption-text">Figure 13. MNIST digit &#8220;1&#8221;</figcaption></figure>
<p>The code above prints (1797, 64) to show the shape of input data matrix and the pixelated digit &#8220;1&#8221; in the image above.  The code we are going to write in this neural networks tutorial will try and estimate the digits that these pixels represent (using neural networks of course). First things first, we need to get the input data in shape. To do so, we need to do two things:</p>
<ol>
<li>Scale the data</li>
<li>Split the data into test and train sets</li>
</ol>
<h3 id="scaling-data">5.1 Scaling data</h3>
<p>Why do we need to scale the input data?  First, have a look at one of the dataset pixel representations:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">digits.data[0,:]
Out[2]:
array([  0.,   0.,   5.,  13.,   9.,   1.,   0.,   0.,   0.,   0.,  13.,
        15.,  10.,  15.,   5.,   0.,   0.,   3.,  15.,   2.,   0.,  11.,
         8.,   0.,   0.,   4.,  12.,   0.,   0.,   8.,   8.,   0.,   0.,
         5.,   8.,   0.,   0.,   9.,   8.,   0.,   0.,   4.,  11.,   0.,
         1.,  12.,   7.,   0.,   0.,   2.,  14.,   5.,  10.,  12.,   0.,
         0.,   0.,   0.,   6.,  13.,  10.,   0.,   0.,   0.])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Notice that the input data ranges from 0 up to 15?  It&#8217;s standard practice to scale the input data so that it all fits mostly between either 0 to 1 or with a small range centred around 0 i.e. -1 to 1.  Why?  Well, it can help the convergence of the neural network and is especially important if we are combining different data types.  Thankfully, this is easily done using sci-kit learn:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from sklearn.preprocessing import StandardScaler
X_scale = StandardScaler()
X = X_scale.fit_transform(digits.data)
X[0,:]
Out[3]:
array([ 0.        , -0.33501649, -0.04308102,  0.27407152, -0.66447751,
       -0.84412939, -0.40972392, -0.12502292, -0.05907756, -0.62400926,
        0.4829745 ,  0.75962245, -0.05842586,  1.12772113,  0.87958306,
       -0.13043338, -0.04462507,  0.11144272,  0.89588044, -0.86066632,
       -1.14964846,  0.51547187,  1.90596347, -0.11422184, -0.03337973,
        0.48648928,  0.46988512, -1.49990136, -1.61406277,  0.07639777,
        1.54181413, -0.04723238,  0.        ,  0.76465553,  0.05263019,
       -1.44763006, -1.73666443,  0.04361588,  1.43955804,  0.        ,
       -0.06134367,  0.8105536 ,  0.63011714, -1.12245711, -1.06623158,
        0.66096475,  0.81845076, -0.08874162, -0.03543326,  0.74211893,
        1.15065212, -0.86867056,  0.11012973,  0.53761116, -0.75743581,
       -0.20978513, -0.02359646, -0.29908135,  0.08671869,  0.20829258,
       -0.36677122, -1.14664746, -0.5056698 , -0.19600752])</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The scikit learn standard scaler by default normalises the data by subtracting the mean and dividing by the standard deviation.  As can be observed, most of the data points are centered around zero and contained within -2 and 2.  This is a good starting point.  There is no real need to scale the output data $y$.</p>
<h3 id="test-and-train">5.2 Creating test and training datasets</h3>
<p>In machine learning, there is a phenomenon called &#8220;overfitting&#8221;. This occurs when models, during training, become too complex &#8211; they become really well adapted to predict the training data, but when they are asked to predict something based on new data that they haven&#8217;t &#8220;seen&#8221; before, they perform poorly. In other words, the models don&#8217;t <em>generalise</em> very well. To make sure that we are not creating models which are too complex, it is common practice to split the dataset into a <em>training</em> set and a <em>test </em>set. The training set is, obviously, the data that the model will be trained on, and the test set is the data that the model will be tested on after it has been trained. The amount of training data is always more numerous than the testing data, and is usually between 60-80% of the total dataset.</p>
<p>Again, scikit learn makes this splitting of the data into training and testing sets easy:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from sklearn.model_selection import train_test_split
y = digits.target
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>In this case, we&#8217;ve made the test set to be 40% of the total data, leaving 60% to train with. The train_test_split function in scikit learn pushes the data randomly into the different datasets &#8211; in other words, it doesn&#8217;t take the first 60% of rows as the training set and the second 40% of rows as the test set. This avoids data collection artefacts from degrading the performance of the model.</p>
<h3 id="setting-up-output">5.3 Setting up the output layer</h3>
<p>As you would have been able to gather, we need the output layer to predict whether the digit represented by the input pixels is between 0 and 9. Therefore, a sensible neural network architecture would be to have an output layer of 10 nodes, with each of these nodes representing a digit from 0 to 9. We want to train the network so that when, say, an image of the digit &#8220;5&#8221; is presented to the neural network, the node in the output layer representing 5 has the highest value. Ideally, we would want to see an output looking like this: [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]. However, in reality, we can settle for something like this: [0.01, 0.1, 0.2, 0.05, 0.3, 0.8, 0.4, 0.03, 0.25, 0.02]. In this case, we can take the maximum index of the output array and call that our predicted digit.</p>
<p>For the MNIST data supplied in the scikit learn dataset, the &#8220;targets&#8221; or the classification of the handwritten digits is in the form of a single number. We need to convert that single number into a vector so that it lines up with our 10 node output layer. In other words, if the target value in the dataset is &#8220;1&#8221; we want to convert it into the vector: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]. The code below does just that:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">import numpy as np
def convert_y_to_vect(y):
    y_vect = np.zeros((len(y), 10))
    for i in range(len(y)):
        y_vect[i, y[i]] = 1
    return y_vect
y_v_train = convert_y_to_vect(y_train)
y_v_test = convert_y_to_vect(y_test)
y_train[0], y_v_train[0]
Out[8]:
(1, array([ 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.]))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>&nbsp;</p>
<p>As can be observed above, the MNIST target (1) has been converted into the vector [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], which is what we want.</p>
<h3 id="creating-nn">5.4 Creating the neural network</h3>
<p>The next step is to specify the structure of the neural network. For the input layer, we know we need 64 nodes to cover the 64 pixels in the image. As discussed, we need 10 output layer nodes to predict the digits. We&#8217;ll also need a hidden layer in our network to allow for the complexity of the task. Usually, the number of hidden layer nodes is somewhere between the number of input layers and the number of output layers. Let&#8217;s define a simple Python list that designates the structure of our network:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">nn_structure = [64, 30, 10]</code></pre> <div class="code-embed-infos"> </div> </div>
<p>We&#8217;ll use sigmoid activation functions again, so let&#8217;s setup the sigmoid function and its derivative:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def f(x):
    return 1 / (1 + np.exp(-x))
def f_deriv(x):
    return f(x) * (1 - f(x))</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Ok, so we now have an idea of what our neural network will look like. How do we train it? Remember the algorithm from <a href="#final-gradient-desc-algo">Section 4.9</a> , which we&#8217;ll repeat here for ease of access and review:</p>
<p>Randomly initialise the weights for each layer $W^{(l)}$<br />
While iterations &lt; iteration limit:<br />
1. Set $\Delta W$ and $\Delta b$ to zero<br />
2. For samples 1 to m:<br />
a. Perform a feed foward pass through all the $n_l$ layers. Store the activation function outputs $h^{(l)}$<br />
b. Calculate the $\delta^{(n_l)}$ value for the output layer<br />
c. Use backpropagation to calculate the $\delta^{(l)}$ values for layers 2 to $n_l-1$<br />
d. Update the $\Delta W^{(l)}$ and $\Delta b^{(l)}$ for each layer<br />
3. Perform a gradient descent step using:</p>
<p>$W^{(l)} = W^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta W^{(l)} \right]$<br />
$b^{(l)} = b^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta b^{(l)}\right]$</p>
<p>So the first step is to initialise the weights for each layer. To make it easy to organise the various layers, we&#8217;ll use Python dictionary objects (initialised by {}). Finally, the weights have to be initialised with random values &#8211; this is to ensure that the neural network will converge correctly during training. We use the numpy library random_sample function to do this. The weight initialisation code is shown below:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">import numpy.random as r
def setup_and_init_weights(nn_structure):
    W = {}
    b = {}
    for l in range(1, len(nn_structure)):
        W[l] = r.random_sample((nn_structure[l], nn_structure[l-1]))
        b[l] = r.random_sample((nn_structure[l],))
    return W, b</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The next step is to set the mean accumulation values $\Delta W$ and $\Delta b$ to zero (they need to be the same size as the weight and bias matrices):</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def init_tri_values(nn_structure):
    tri_W = {}
    tri_b = {}
    for l in range(1, len(nn_structure)):
        tri_W[l] = np.zeros((nn_structure[l], nn_structure[l-1]))
        tri_b[l] = np.zeros((nn_structure[l],))
    return tri_W, tri_b</code></pre> <div class="code-embed-infos"> </div> </div>
<p>If we now step into the gradient descent loop, the first step is to perform a feed forward pass through the network. The code below is a variation on the feed forward function created in <a href="#the-feed-forward-pass">Section 3</a>:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def feed_forward(x, W, b):
    h = {1: x}
    z = {}
    for l in range(1, len(W) + 1):
        # if it is the first layer, then the input into the weights is x, otherwise, 
        # it is the output from the last layer
        if l == 1:
            node_in = x
        else:
            node_in = h[l]
        z[l+1] = W[l].dot(node_in) + b[l] # z^(l+1) = W^(l)*h^(l) + b^(l)  
        h[l+1] = f(z[l+1]) # h^(l) = f(z^(l)) 
    return h, z</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Finally, we have to then calculate the output layer delta $\delta^{(n_l)}$ and any hidden layer delta values $\delta^{(l)}$ to perform the backpropagation pass:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def calculate_out_layer_delta(y, h_out, z_out):
    # delta^(nl) = -(y_i - h_i^(nl)) * f&#039;(z_i^(nl))
    return -(y-h_out) * f_deriv(z_out)

def calculate_hidden_delta(delta_plus_1, w_l, z_l):
    # delta^(l) = (transpose(W^(l)) * delta^(l+1)) * f&#039;(z^(l))
    return np.dot(np.transpose(w_l), delta_plus_1) * f_deriv(z_l)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Now we can put all the steps together into the final function:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def train_nn(nn_structure, X, y, iter_num=3000, alpha=0.25):
    W, b = setup_and_init_weights(nn_structure)
    cnt = 0
    m = len(y)
    avg_cost_func = []
    print(&#039;Starting gradient descent for {} iterations&#039;.format(iter_num))
    while cnt &lt; iter_num:
        if cnt%1000 == 0:
            print(&#039;Iteration {} of {}&#039;.format(cnt, iter_num))
        tri_W, tri_b = init_tri_values(nn_structure)
        avg_cost = 0
        for i in range(len(y)):
            delta = {}
            # perform the feed forward pass and return the stored h and z values, to be used in the
            # gradient descent step
            h, z = feed_forward(X[i, :], W, b)
            # loop from nl-1 to 1 backpropagating the errors
            for l in range(len(nn_structure), 0, -1):
                if l == len(nn_structure):
                    delta[l] = calculate_out_layer_delta(y[i,:], h[l], z[l])
                    avg_cost += np.linalg.norm((y[i,:]-h[l]))
                else:
                    if l &gt; 1:
                        delta[l] = calculate_hidden_delta(delta[l+1], W[l], z[l])
                    # triW^(l) = triW^(l) + delta^(l+1) * transpose(h^(l))
                    tri_W[l] += np.dot(delta[l+1][:,np.newaxis], np.transpose(h[l][:,np.newaxis])) 
                    # trib^(l) = trib^(l) + delta^(l+1)
                    tri_b[l] += delta[l+1]
        # perform the gradient descent step for the weights in each layer
        for l in range(len(nn_structure) - 1, 0, -1):
            W[l] += -alpha * (1.0/m * tri_W[l])
            b[l] += -alpha * (1.0/m * tri_b[l])
        # complete the average cost calculation
        avg_cost = 1.0/m * avg_cost
        avg_cost_func.append(avg_cost)
        cnt += 1
    return W, b, avg_cost_func</code></pre> <div class="code-embed-infos"> </div> </div>
<p>The function above deserves a bit of explanation. First, we aren&#8217;t setting a termination of the gradient descent process based on some change or precision of the cost function. Rather, we are just running it for a set number of iterations (3,000 in this case) and we&#8217;ll monitor how the average cost function changes as we progress through the training (avg_cost_func list in the above code). In each iteration of the gradient descent, we cycle through each training sample (range(len(y)) and perform the feed forward pass and then the backpropagation. The backpropagation step is an iteration through the layers starting at the output layer and working backwards &#8211; range(len(nn_structure), 0, -1). We calculate the average cost, which we are tracking during the training, at the output layer (l == len(nn_structure)). We also update the mean accumulation values, $\Delta W$ and $\Delta b$, designated as tri_W and tri_b, for every layer apart from the output layer (there are no weights connecting the output layer to any further layer).</p>
<p>Finally, after we have looped through all the training samples, accumulating the tri_W and tri_b values, we perform a gradient descent step change in the weight and bias values:<br />
$$W^{(l)} = W^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta W^{(l)} \right]$$<br />
$$b^{(l)} = b^{(l)} &#8211; \alpha \left[\frac{1}{m} \Delta b^{(l)}\right]$$</p>
<p>After the process is completed, we return the trained weight and bias values, along with our tracked average cost for each iteration. Now it&#8217;s time to run the function &#8211; NOTE: this may take a few minutes depending on the capabilities of your computer.</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">W, b, avg_cost_func = train_nn(nn_structure, X_train, y_v_train)</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Now we can have a look at how the average cost function decreased as we went through the gradient descent iterations of the training, slowly converging on a minimum in the function:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">plt.plot(avg_cost_func)
plt.ylabel(&#039;Average J&#039;)
plt.xlabel(&#039;Iteration number&#039;)
plt.show()</code></pre> <div class="code-embed-infos"> </div> </div>
<p><img class="wp-image-98 size-medium aligncenter" src="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Average-J-vs-iterations-300x205.png" alt="" width="300" height="205" srcset="http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Average-J-vs-iterations-300x205.png 300w, http://adventuresinmachinelearning.com/wp-content/uploads/2017/03/Average-J-vs-iterations.png 389w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p>We can see in the above plot, that by 3,000 iterations of our gradient descent our average cost function value has started to &#8220;plateau&#8221; and therefore any further increases in the number of iterations isn&#8217;t likely to improve the performance of the network by much.</p>
<h3 id="assessing">5.5 Assessing the accuracy of the trained model</h3>
<p>Now that we&#8217;ve trained our MNIST neural network, we want to see how it performs on the test set. Is our model any good? Given a test input (64 pixels), we need to find what the output of our neural network is &#8211; we do that by simply performing a feed forward pass through the network using our trained weight and bias values. As discussed previously, we assess the prediction of the output layer by taking the node with the maximum output as the predicted digit. We can use the numpy.argmax function for this, which returns the index of the array value with the highest value:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">def predict_y(W, b, X, n_layers):
    m = X.shape[0]
    y = np.zeros((m,))
    for i in range(m):
        h, z = feed_forward(X[i, :], W, b)
        y[i] = np.argmax(h[n_layers])
    return y</code></pre> <div class="code-embed-infos"> </div> </div>
<p>Finally, we can assess the accuracy of the prediction (i.e. the percentage of times the network predicted the handwritten digit correctly), by using the scikit learn accuracy_score function:</p>
<div class="code-embed-wrapper"> <pre class="language-python code-embed-pre line-numbers"  data-start="1" data-line-offset="0"><code class="language-python code-embed-code">from sklearn.metrics import accuracy_score
y_pred = predict_y(W, b, X_test, 3)
accuracy_score(y_test, y_pred)*100</code></pre> <div class="code-embed-infos"> </div> </div>
<p>This gives an 86% accuracy of predicting the digits.  Sounds pretty good right? Well actually no, it&#8217;s pretty bad. The current state-of-the-art deep learning algorithms achieve accuracy scores of 99.7% (see <a href="http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html" target="_blank" rel="noopener noreferrer">here</a>), so we are a fair way off that sort of accuracy.  There are many more exciting things to learn &#8211; my next post will cover some tips and tricks on how to improve the accuracy substantially on this simple neural network.  However, beyond that, we have a whole realm of state-of-the-art deep learning algorithms to learn and investigate, from convolution neural networks to deep belief nets and recurrent neural networks.  If you followed along ok with this post, you will be in a good position to advance to these newer techniques.</p>
<p>Stick around to find out more about this rapidly advancing area of machine learning.  As a start, check out these posts:<br />
<a href="http://adventuresinmachinelearning.com/python-tensorflow-tutorial/">Python TensorFlow Tutorial – Build a Neural Network</a><br />
<a href="http://adventuresinmachinelearning.com/improve-neural-networks-part-1/">Improve your neural networks – Part 1 [TIPS AND TRICKS]</a><br />
<a href="http://adventuresinmachinelearning.com/stochastic-gradient-descent/">Stochastic Gradient Descent – Mini-batch and more</a></p>
<hr />
<p><strong>Recommended online course: </strong>If you&#8217;d like to dig a little deeper still and you like video courses, I&#8217;d recommend the following inexpensive Udemy course on neural networks: <a href="https://click.linksynergy.com/link?id=Jbc0N5ZkDzk&amp;offerid=323058.1151632&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fdeeplearning%2F" target="new">Deep Learning A-Z: Hands-On Artificial Neural Networks</a><img src="https://ad.linksynergy.com/fs-bin/show?id=Jbc0N5ZkDzk&amp;bids=323058.1151632&amp;type=2&amp;subid=0" width="1" height="1" border="0" /></p>
<hr />
<p>The post <a rel="nofollow" href="http://adventuresinmachinelearning.com/neural-networks-tutorial/">Neural Networks Tutorial &#8211; A Pathway to Deep Learning</a> appeared first on <a rel="nofollow" href="http://adventuresinmachinelearning.com">Adventures in Machine Learning</a>.</p>
]]></content:encoded>
			<wfw:commentRss>http://adventuresinmachinelearning.com/neural-networks-tutorial/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
		</item>
	</channel>
</rss>
